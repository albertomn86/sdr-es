<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ajuste de frecuencia en recepción de satélites</title>
    <url>/2020/02/18/ajuste-frecuencia-doppler-orbitron/</url>
    <content><![CDATA[<p>Cuando realizamos seguimiento de satélites nos encontramos con que la frecuencia en la que deberíamos recibir una señal no se ajusta con la que estamos recibiendo y además cambia durante el pase. Esto se debe al conocido como <strong>efecto Doppler</strong>.</p>
<p>El efecto Doppler, llamado así por el físico austriaco Christian Andreas Doppler, es el cambio de frecuencia asociado a la alta velocidad que presenta el satélite con respecto a una estación terrestre.</p>
<p>Usando Orbitron y el plugin DDETracker podemos hacer que SDR# realice la correción y el ajuste de la frecuencia de recepción de forma automática y en tiempo real. De esta forma evitaremos el tener que ajustarla manualmente y tendremos siempre la señal correctamente centrada.</p>
<a id="more"></a>


<h2 id="Correccion-automatica-de-la-frecuencia-con-Orbitron"><a href="#Correccion-automatica-de-la-frecuencia-con-Orbitron" class="headerlink" title="Corrección automática de la frecuencia con Orbitron"></a>Corrección automática de la frecuencia con Orbitron</h2><p>En el post anterior <a href="https://sdr-es.com/2020/01/23/seguimiento-satelites-orbitron/">“Seguimiento de satélites con Orbitron”</a> vimos como instalar y configurar este programa para realizar el seguimiento de satélites. Este programa también nos va a permitir corregir en tiempo real la frecuencia del satélite que estemos siguiendo, y además podremos enviar esta frecuencia a SDR# para que la ajuste de manera automática. De esta forma no tendremos que preocuparnos por ajustarla manualmente y tendremos siempre la señal perfectamente sintonizada.</p>
<p>El primer paso es indicarle a Orbitron la frecuencia del satélite para que pueda llevar a cabo el ajuste. Para ello seleccionamos el satélite para marcarlo como activo y vamos a la pestaña <em>Sat/Orbit info</em>.</p>
<p>Hacemos doble click en el cuadro de texto de la derecha para que nos cargue la plantilla por defecto.</p>
<img src="/2020/02/18/ajuste-frecuencia-doppler-orbitron/orbitron-plantilla.jpg" class="" title="Orbitron">

<p>Ahora introducimos la frecuencia en MHz en la etiqueta <strong>DNLINK</strong>.</p>
<img src="/2020/02/18/ajuste-frecuencia-doppler-orbitron/orbitron-dnlink.jpg" class="" title="Introducir frecuencia en Orbitron">

<p>Los demás datos son opcionales, pero podemos completarlos para tener más información sobre el satélite.</p>
<h2 id="Instalacion-de-DDETracker"><a href="#Instalacion-de-DDETracker" class="headerlink" title="Instalación de DDETracker"></a>Instalación de DDETracker</h2><p>El siguiente paso es instalar un plugin en SDR# que nos permita cambiar la frecuencia de forma automática.<br>En este ejemplo vamos a usar el plugin <strong>DDETracker</strong> que podemos descargar desde el siguiente link:</p>
<p><a href="http://rtl-sdr.ru/uploads/download/ddetracker.zip" target="_blank" rel="noopener"><center>http://rtl-sdr.ru/uploads/download/ddetracker.zip</center></a></p>
<p>Una vez descargado el archivo y descomprimido, tenemos que incorporarlo a SDR#. Para ello seguimos los siguientes pasos:</p>
<ol>
<li><p>Copiamos los archivos que se indican en la siguiente captura dentro de la carpeta de instalacion de SDR#.</p>
 <img src="/2020/02/18/ajuste-frecuencia-doppler-orbitron/dde-archivos.jpg" class="" title="Archivos de DDETracker">
</li>
<li><p>Insertamos la siguiente línea dentro del archivo <em><strong>Plugins.xml</strong></em> que encontraremos dentro de la carpeta de SDR#.</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;add key&#x3D;&quot;DDE Tracking Client&quot; value&#x3D;&quot;SDRSharp.DDETracker.DdeTrackingPlugin,SDRSharp.DDETracker&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
 </br>
 <img src="/2020/02/18/ajuste-frecuencia-doppler-orbitron/dde-magicline.jpg" class="" title="Magicline de DDETracker">


</li>
</ol>
<ol start="3">
<li><p>Añadimos las siguientes líneas al archivo de configuración de Orbitron <em><strong>Setup.cfg</strong></em>, que encontramos dentro de la carpeta <em>Config</em> en el directorio de instalación de Orbitron.<br> Debemos indicar la ruta completa en la que hemos colocado el archivo <em>SDRSharpDriverDDE.exe</em> en el paso 1.</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Drivers]</span><br><span class="line">SDRSharp&#x3D;C:\SDR\SDRSharp\SDRSharpDriverDDE.exe</span><br></pre></td></tr></table></figure>
 </br>
 <img src="/2020/02/18/ajuste-frecuencia-doppler-orbitron/orbitron-config.jpg" class="" title="Orbitron">

<p> Por último, reiniciamos Orbitron para aplicar los cambios.</p>
</li>
</ol>
<p>Ahora que tenemos el plugin instalado, iniciamos SDR# y deberíamos ver el nuevo plugin en la lista. Lo iniciaremos haciendo click en <em>Scheduler</em>.</p>
<img src="/2020/02/18/ajuste-frecuencia-doppler-orbitron/dde-plugin.jpg" class="" title="DDETracker">


<h2 id="Conexion-con-DDETracker"><a href="#Conexion-con-DDETracker" class="headerlink" title="Conexión con DDETracker"></a>Conexión con DDETracker</h2><p>Ahora ya podemos decirle a Orbitron que mande los datos a SDR#. Para ello vamos a Orbitron y seleccionamos en Driver <em>“SDRSharp”</em> y hacemos click en el botón de conexión:</p>
<img src="/2020/02/18/ajuste-frecuencia-doppler-orbitron/orbitron-driver.jpg" class="" title="Orbitron">

<p>Ahora ya podemos ver que DDETracker recibe los datos del satélite que tenemos activo en Orbitron.</p>
<img src="/2020/02/18/ajuste-frecuencia-doppler-orbitron/dde-active.jpg" class="" title="DDETracker activo">


<h2 id="Configurar-satelites-en-DDETracker"><a href="#Configurar-satelites-en-DDETracker" class="headerlink" title="Configurar satélites en DDETracker"></a>Configurar satélites en DDETracker</h2><p>Para que el plugin pueda iniciar el seguimiento, debemos indicarle algunos datos sobre el satélite en cuestión.<br>Para introducir los datos, hacemos click en sobre el botón Config que aparece en el plugin y se abrirá una ventana para introducir los datos.</p>
<img src="/2020/02/18/ajuste-frecuencia-doppler-orbitron/dde-config.jpg" class="" title="DDETracker config">


<p>Hacemos click en <em>“Add new satellite”</em> para crear un nuevo satélite.<br>Lo primero es introducir el nombre. Este nombre debe coincidir exactamente con el nombre del satélite que aparece en el plugin.<br>Si el nombre es muy largo o contiene caracteres especiales, podremos usar el asterisco (*) para omitir ciertas partes.</p>
<p>Como podemos ver en la ventana tenemos dos bloques para introducir las acciones que SDR# debe realizar. En el bloque <strong>AOS</strong> (Acquisition of Signal) le diremos qué debe hacer cuando el satélite comience a verse sobre el horizonte en nuestra posición y en el bloque inferior <strong>LOS</strong> (Loss Of Signal) le indicamos que hará cuando termine el pase.</p>
<p>Estas acciones podemos escribirlas manualmente o seleccionarlas de la columna de la derecha e ir insertando con el botón “<strong>&lt;&lt;</strong>“ dónde corresponda.</p>
<p>En el caso de nuestro ejemplo haremos las siguientes acciones:</p>
<p><strong>AOS:</strong><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">radio_Start</span><br><span class="line">radio_modulation_type&lt;USB&gt;</span><br><span class="line">radio_bandwidth_Hz&lt;4800&gt;</span><br><span class="line">radio_center_frequency_Hz&lt;145935000&gt;</span><br><span class="line">radio_tracking_frequency_On</span><br></pre></td></tr></table></figure></p>
<p><strong>LOS:</strong><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">radio_tracking_frequency_Off</span><br><span class="line">radio_Stop</span><br></pre></td></tr></table></figure></p>
</br>
<img src="/2020/02/18/ajuste-frecuencia-doppler-orbitron/dde-configured.jpg" class="" title="DDETracker FUNCUBE">

<p>Con esto ya tendríamos los datos del satélite introducidos. Ahora cuando el satélite se acerque a nuestra posición, SDR# se iniciará para recibir la señal de forma automática y se detendrá cuando el satélite desaparezca por el horizonte.</p>
<img src="/2020/02/18/ajuste-frecuencia-doppler-orbitron/sdr-sharp.jpg" class="" title="DDETracker activo">
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>Orbitron</tag>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Elección del dispositivo SDR</title>
    <url>/2020/03/16/eleccion-sdr/</url>
    <content><![CDATA[<p>Existen actualmente en el mercado distintos tipos de dispositivos SDR con determinadas características y prestaciones, y por supuesto con distinto rango de precios. Desde los dispositivos de unos pocos euros, hasta los dispositivos de varios cientos de euros, todos nos pueden servir para recibir señales de radio.<br>La finalidad este artículo es orientarnos para escoger el dispositivo que más se ajuste a nuestras necesidades y casos de uso. Para ello se han seleccionado algunos de los dispositivos más conocidos y que habitualmente se recomiendan, y se ha elaborado una breve descripción de cada uno de ellos con algunas de sus características más reseñables.</p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>Dispositivo</th>
<th>Sintonizador</th>
<th align="right">Ancho de Banda</th>
<th>Rango frecuencias</th>
<th>Bias Tee</th>
<th align="right">Precio</th>
</tr>
</thead>
<tbody><tr>
<td>Modelos genéricos</td>
<td>R820T2</td>
<td align="right">2.4 MHz</td>
<td>25 MHz – 1700 MHz</td>
<td>No</td>
<td align="right">~10€</td>
</tr>
<tr>
<td>RTL-SDR Blog V3</td>
<td>R820T2</td>
<td align="right">2.4 MHz</td>
<td>500 kHz – 1766 MHz</td>
<td>Sí</td>
<td align="right">~28€</td>
</tr>
<tr>
<td>Nooelec NESDR SMArt v4</td>
<td>R820T2</td>
<td align="right">2.4 MHz</td>
<td>25 MHz - 1750 MHz</td>
<td>No</td>
<td align="right">~32€</td>
</tr>
<tr>
<td>Nooelec NESDR SMArTee v2</td>
<td>R820T2</td>
<td align="right">2.4 MHz</td>
<td>25 MHz - 1750 MHz</td>
<td>Sí</td>
<td align="right">~36€</td>
</tr>
<tr>
<td>Nooelec NESDR SMArt XTR</td>
<td>E4000</td>
<td align="right">2.4 MHz</td>
<td>65 MHz - 2300 MHz</td>
<td>No</td>
<td align="right">~44€</td>
</tr>
<tr>
<td>Nooelec NESDR SMArTee XTR</td>
<td>E4000</td>
<td align="right">2.4 MHz</td>
<td>65 MHz - 2300 MHz</td>
<td>Sí</td>
<td align="right">~46€</td>
</tr>
<tr>
<td>Nooelec NESDR Nano 3</td>
<td>R820T2</td>
<td align="right">2.4 MHz</td>
<td>25 MHz - 1700 MHz</td>
<td>No</td>
<td align="right">~32€</td>
</tr>
<tr>
<td>Airspy Mini</td>
<td>R820T2</td>
<td align="right">6 MHz</td>
<td>24 MHz - 1700 MHz</td>
<td>Sí</td>
<td align="right">~140€</td>
</tr>
<tr>
<td>Airspy R2</td>
<td>R820T2</td>
<td align="right">10 MHz</td>
<td>24 MHz - 1700 MHz</td>
<td>Sí</td>
<td align="right">~235€</td>
</tr>
<tr>
<td>Airspy HF+ Discovery</td>
<td>-</td>
<td align="right">610 kHz</td>
<td>0.5 kHz - 31 MHz, 60 - 260 MHz</td>
<td>No</td>
<td align="right">~210€</td>
</tr>
<tr>
<td>Airspy HF+ Dual Port</td>
<td>-</td>
<td align="right">610 kHz</td>
<td>9 kHz - 31 MHz, 60 - 260 MHz</td>
<td>No</td>
<td align="right">~240€</td>
</tr>
<tr>
<td>SDRplay RSP1A</td>
<td>-</td>
<td align="right">10 MHz</td>
<td>1 kHz - 2000 MHz</td>
<td>Sí</td>
<td align="right">~115€</td>
</tr>
<tr>
<td>SDRplay RSPdx</td>
<td>-</td>
<td align="right">10 MHz</td>
<td>1 kHz - 2000 MHz</td>
<td>Sí</td>
<td align="right">~228€</td>
</tr>
<tr>
<td>SDRplay RSPduo</td>
<td>-</td>
<td align="right">10 MHz</td>
<td>1 kHz - 2000 MHz</td>
<td>Sí</td>
<td align="right">~290€</td>
</tr>
<tr>
<td>KiwiSDR</td>
<td>-</td>
<td align="right">32 MHz</td>
<td>10 KHz - 30 MHz</td>
<td>No</td>
<td align="right">~330€</td>
</tr>
</tbody></table>
<h2 id="Modelos-genericos"><a href="#Modelos-genericos" class="headerlink" title="Modelos genéricos"></a>Modelos genéricos</h2><img src="/2020/03/16/eleccion-sdr/SDR-generico.jpg" class="" width="300" title="RTL-SDR genérico">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 2,4 MHz.</li>
<li><strong>ADC:</strong> RTL2832U 8-bits.</li>
<li><strong>Sintonizador:</strong> R820T2.</li>
<li><strong>Rango de frecuencias:</strong> 25 MHz - 1.700 MHz (rendimiento pobre por encima de 1.000 MHz).</li>
<li><strong>Bias-Tee:</strong> No.</li>
<li><strong>TCXO:</strong> No.</li>
<li><strong>Conector:</strong> MCX hembra.</li>
<li>Disponibles en eBay, AliExpress, Amazon.</li>
</ul>
<h2 id="RTL-SDR-Blog-V3"><a href="#RTL-SDR-Blog-V3" class="headerlink" title="RTL-SDR Blog V3"></a>RTL-SDR Blog V3</h2><img src="/2020/03/16/eleccion-sdr/rtlsdrblog.jpg" class="" width="400" title="RTL-SDR Blog V3">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 2,4 MHz.</li>
<li><strong>ADC:</strong> RTL2832U 8-bits.</li>
<li><strong>Sintonizador:</strong> R820T2.</li>
<li><strong>Rango de frecuencias:</strong> 500 kHz – 1.766 MHz (500 kHz – 24 MHz en modo <em>Direct Sampling</em>).</li>
<li><strong>Bias-Tee:</strong> Sí, activación por software (4,5V 180mA).</li>
<li><strong>TCXO:</strong> 1 PPM.</li>
<li><strong>Conector:</strong> SMA hembra.</li>
<li>Disponible en RTL-SDR.com y Astroradio.</li>
<li>Más información: <a href="https://www.rtl-sdr.com/wp-content/uploads/2018/02/RTL-SDR-Blog-V3-Datasheet.pdf" target="_blank" rel="noopener">Datasheet (PDF)</a>.</li>
</ul>
<h2 id="Nooelec-NESDR-SMArt-v4"><a href="#Nooelec-NESDR-SMArt-v4" class="headerlink" title="Nooelec NESDR SMArt v4"></a>Nooelec NESDR SMArt v4</h2><img src="/2020/03/16/eleccion-sdr/smartv4.jpg" class="" width="500" title="Nooelec NESDR SMArt v4">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 2,4 MHz.</li>
<li><strong>ADC:</strong> RTL2832U 8-bits.</li>
<li><strong>Sintonizador:</strong> R820T2.</li>
<li><strong>Rango de frecuencias:</strong> 25 MHz - 1.750 MHz.</li>
<li><strong>Bias-Tee:</strong> No.</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> SMA hembra.</li>
<li>Disponible en nooelec.com y Amazon España.</li>
<li>Más información: <a href="https://www.nooelec.com/store/sdr/sdr-receivers/nesdr-smart-sdr.html" target="_blank" rel="noopener">Nooelec</a>.</li>
</ul>
<h2 id="Nooelec-NESDR-SMArTee-v2"><a href="#Nooelec-NESDR-SMArTee-v2" class="headerlink" title="Nooelec NESDR SMArTee v2"></a>Nooelec NESDR SMArTee v2</h2><img src="/2020/03/16/eleccion-sdr/smarteev2.jpg" class="" width="500" title="Nooelec NESDR SMArTee v2">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 2,4 MHz.</li>
<li><strong>ADC:</strong> RTL2832U 8-bits.</li>
<li><strong>Sintonizador:</strong> R820T2.</li>
<li><strong>Rango de frecuencias:</strong> 25 MHz - 1.750 MHz.</li>
<li><strong>Bias-Tee:</strong> Sí, siempre activo (4,5V 250mA).</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> SMA hembra.</li>
<li>Disponible en nooelec.com y Amazon España.</li>
<li>Más información: <a href="https://www.nooelec.com/store/sdr/sdr-receivers/nesdr-smartee-sdr.html" target="_blank" rel="noopener">Nooelec</a>.</li>
</ul>
<h2 id="Nooelec-NESDR-SMArt-XTR"><a href="#Nooelec-NESDR-SMArt-XTR" class="headerlink" title="Nooelec NESDR SMArt XTR"></a>Nooelec NESDR SMArt XTR</h2><img src="/2020/03/16/eleccion-sdr/smartxtr.jpg" class="" width="450" title="Nooelec NESDR SMArt XTR">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 2,4 MHz.</li>
<li><strong>ADC:</strong> RTL2832U 8-bits.</li>
<li><strong>Sintonizador:</strong> E4000.</li>
<li><strong>Rango de frecuencias:</strong> 65 MHz - 2.300 MHz. No recibe en un pequeño intervalo sobre los 1.100 MHz.</li>
<li><strong>Bias-Tee:</strong> No.</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> SMA hembra.</li>
<li>Disponible en nooelec.com y Amazon España.</li>
<li>Más información: <a href="https://www.nooelec.com/store/sdr/sdr-receivers/nesdr-smart-xtr-sdr.html" target="_blank" rel="noopener">Nooelec</a>.</li>
</ul>
<h2 id="Nooelec-NESDR-SMArTee-XTR"><a href="#Nooelec-NESDR-SMArTee-XTR" class="headerlink" title="Nooelec NESDR SMArTee XTR"></a>Nooelec NESDR SMArTee XTR</h2><img src="/2020/03/16/eleccion-sdr/smarteextr.jpg" class="" width="500" title="Nooelec NESDR SMArTee XTR">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 2,4 MHz.</li>
<li><strong>ADC:</strong> RTL2832U 8-bits.</li>
<li><strong>Sintonizador:</strong> E4000.</li>
<li><strong>Rango de frecuencias:</strong> 65 MHz - 2.300 MHz. No recibe en un pequeño intervalo sobre los 1.100 MHz.</li>
<li><strong>Bias-Tee:</strong> Sí, siempre activo (3,3V 100mA).</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> SMA hembra.</li>
<li>Disponible en nooelec.com y Amazon España.</li>
<li>Más información: <a href="https://www.nooelec.com/store/sdr/sdr-receivers/nesdr-smartee-xtr-sdr.html" target="_blank" rel="noopener">Nooelec</a>.</li>
</ul>
<h2 id="Nooelec-NESDR-Nano-3"><a href="#Nooelec-NESDR-Nano-3" class="headerlink" title="Nooelec NESDR Nano 3"></a>Nooelec NESDR Nano 3</h2><img src="/2020/03/16/eleccion-sdr/nano3.jpg" class="" width="200" title="Nooelec NESDR Nano 3">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 2,4 MHz.</li>
<li><strong>ADC:</strong> RTL2832U 8-bits.</li>
<li><strong>Sintonizador:</strong> R820T2.</li>
<li><strong>Rango de frecuencias:</strong> 25 MHz - 1.750 MHz.</li>
<li><strong>Bias-Tee:</strong> No.</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> MCX hembra. Incluye adaptador a SMA hembra.</li>
<li>Disponible en nooelec.com y Amazon España.</li>
<li>Más información: <a href="https://www.nooelec.com/store/sdr/sdr-receivers/nesdr-nano-three.html" target="_blank" rel="noopener">Nooelec</a>.</li>
</ul>
<h2 id="Airspy-Mini"><a href="#Airspy-Mini" class="headerlink" title="Airspy Mini"></a>Airspy Mini</h2><img src="/2020/03/16/eleccion-sdr/airspymini.jpg" class="" width="400" title="Airspy Mini">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 6 MHz.</li>
<li><strong>ADC:</strong> 12-bit (16-bit en <em>Oversampling Mode</em>).</li>
<li><strong>Sintonizador:</strong> R820T2.</li>
<li><strong>Rango de frecuencias:</strong> 24 MHz - 1.700 MHz.</li>
<li><strong>Bias-Tee:</strong> Sí, activación por software (4,5V).</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> SMA hembra.</li>
<li>Disponible en WiMo.</li>
<li>Más información: <a href="https://airspy.com/airspy-mini/" target="_blank" rel="noopener">Airspy</a>.</li>
</ul>
<h2 id="Airspy-R2"><a href="#Airspy-R2" class="headerlink" title="Airspy R2"></a>Airspy R2</h2><img src="/2020/03/16/eleccion-sdr/airspyr2.jpg" class="" width="350" title="Airspy R2">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 10 MHz.</li>
<li><strong>ADC:</strong> 12-bit (16-bit en <em>Oversampling Mode</em>).</li>
<li><strong>Sintonizador:</strong> R820T2.</li>
<li><strong>Rango de frecuencias:</strong> 24 MHz - 1.700 MHz.</li>
<li><strong>Bias-Tee:</strong> Sí, activación por software (4,5V).</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> SMA hembra.</li>
<li>Disponible en WiMo.</li>
<li>Más información: <a href="https://airspy.com/airspy-r2/" target="_blank" rel="noopener">Airspy</a>.</li>
</ul>
<h2 id="Airspy-HF-Discovery"><a href="#Airspy-HF-Discovery" class="headerlink" title="Airspy HF+ Discovery"></a>Airspy HF+ Discovery</h2><img src="/2020/03/16/eleccion-sdr/hfplusdiscovery.jpg" class="" width="400" title="Airspy HF+ Discovery">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 912 kHz.</li>
<li><strong>ADC:</strong> 18-bit DDC.</li>
<li><strong>Rango de frecuencias:</strong> 0,5 kHz - 31 MHz (HF) y 60 - 260 MHz (VHF).</li>
<li><strong>Bias-Tee:</strong> No.</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> SMA hembra.</li>
<li>Disponible en Astroradio y WiMo.</li>
<li>Más información: <a href="https://airspy.com/airspy-hf-discovery" target="_blank" rel="noopener">Airspy</a>.</li>
</ul>
<h2 id="Airspy-HF-Dual-Port"><a href="#Airspy-HF-Dual-Port" class="headerlink" title="Airspy HF+ Dual Port"></a>Airspy HF+ Dual Port</h2><img src="/2020/03/16/eleccion-sdr/hfplusdual.jpg" class="" title="Airspy HF+ Dual Port">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 912 kHz.</li>
<li><strong>ADC:</strong> 18-bit DDC.</li>
<li><strong>Rango de frecuencias:</strong> 9 kHz - 31 MHz (HF) y 60 - 260 MHz (VHF).</li>
<li><strong>Bias-Tee:</strong> No.</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> 2 x SMA hembra.</li>
<li>Disponible en Astroradio y WiMo.</li>
<li>Más información: <a href="https://airspy.com/airspy-hf-plus" target="_blank" rel="noopener">Airspy</a>.</li>
</ul>
<h2 id="SDRplay-RSP1A"><a href="#SDRplay-RSP1A" class="headerlink" title="SDRplay RSP1A"></a>SDRplay RSP1A</h2><img src="/2020/03/16/eleccion-sdr/RSP1A.jpg" class="" width="550" title="SDRplay RSP1A">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 10 MHz.</li>
<li><strong>ADC:</strong> 14-bit.</li>
<li><strong>Rango de frecuencias:</strong> 1 kHz - 2.000 MHz.</li>
<li><strong>Bias-Tee:</strong> Sí, activación por software (4,7V 100mA).</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> SMA hembra.</li>
<li>Disponible en sdrplay.com y Astroradio.</li>
<li>Más información: <a href="https://www.sdrplay.com/docs/RSP1Adatasheetv1.9.pdf" target="_blank" rel="noopener">Datasheet (PDF)</a>, <a href="https://www.sdrplay.com/wp-content/uploads/2018/01/RSP1A-Technical-Information-R1P1.pdf" target="_blank" rel="noopener">Información técnica (PDF)</a>.</li>
</ul>
<h2 id="SDRplay-RSPdx"><a href="#SDRplay-RSPdx" class="headerlink" title="SDRplay RSPdx"></a>SDRplay RSPdx</h2><img src="/2020/03/16/eleccion-sdr/RSPdx.jpg" class="" width="500" title="SDRplay RSPdx">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 10 MHz.</li>
<li><strong>ADC:</strong> 14-bit.</li>
<li><strong>Rango de frecuencias:</strong> 1 kHz - 2.000 MHz.</li>
<li><strong>Bias-Tee:</strong> Sí, activación por software (4,7V 100mA).</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> 2 x SMA hembra, 1 x BNC (hasta 200 MHz). Seleccionables por software.</li>
<li>Disponible en sdrplay.com y Astroradio.</li>
<li>Más información: <a href="https://www.sdrplay.com/resources/RSPdxDatasheet.pdf" target="_blank" rel="noopener">Datasheet (PDF)</a>.</li>
</ul>
<h2 id="SDRplay-RSPduo"><a href="#SDRplay-RSPduo" class="headerlink" title="SDRplay RSPduo"></a>SDRplay RSPduo</h2><img src="/2020/03/16/eleccion-sdr/RSPduo.jpg" class="" width="550" title="SDRplay RSPduo">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 10 MHz (modo <em>single tuner</em>) o 2 fragmentos de hasta 2MHz (modo <em>dual tuner</em>).</li>
<li><strong>ADC:</strong> 14-bit.</li>
<li><strong>Rango de frecuencias:</strong> 1 kHz - 2.000 MHz.</li>
<li><strong>Bias-Tee:</strong> Sí, activación por software (4,7V 100mA).</li>
<li><strong>TCXO:</strong> 0,5 PPM.</li>
<li><strong>Conector:</strong> 2 x SMA hembra, 1 x Conector alta impedancia (1kHz - 30MHz) . Seleccionables por software.</li>
<li>Disponible en sdrplay.com y Astroradio.</li>
<li>Más información: <a href="https://www.sdrplay.com/wp-content/uploads/2018/05/RSPduoDatasheetV0.6.pdf" target="_blank" rel="noopener">Datasheet (PDF)</a>, <a href="https://www.sdrplay.com/wp-content/uploads/2018/06/RSPDuo-Technical-Information-R1P1.pdf" target="_blank" rel="noopener">Información técnica (PDF)</a>.</li>
</ul>
<h2 id="KiwiSDR"><a href="#KiwiSDR" class="headerlink" title="KiwiSDR"></a>KiwiSDR</h2><img src="/2020/03/16/eleccion-sdr/kiwisdr.jpg" class="" width="400" title="KiwiSDR">

<ul>
<li><strong>Ancho de banda:</strong> Hasta 32 MHz.</li>
<li><strong>Rango de frecuencias:</strong> 10 KHz - 30 MHz.</li>
<li><strong>Bias-Tee:</strong> Sí, para antena GPS (3,3V).</li>
<li><strong>Conector:</strong> 2 x SMA hembra, antena RX + antena GPS.</li>
<li>WebSDR con interfaz web OpenWebSDR.</li>
<li>Disponible en Amazon y WiMo. Se vende en un kit compuesto de receptor KiwiSDR, BeagleBone, antena GPS y tarjeta MicroSD con sistema operativo.</li>
<li>Más información: <a href="http://kiwisdr.com/" target="_blank" rel="noopener">kiwisdr.com</a>.</li>
</ul>
]]></content>
      <tags>
        <tag>RTL-SDR</tag>
      </tags>
  </entry>
  <entry>
    <title>Identificación de estaciones de radiodifusión con CSVUserlistBrowser</title>
    <url>/2020/05/10/identificacion-estaciones-csvuserlistbrowser/</url>
    <content><![CDATA[<p>En este artículo vamos a ver como instalar y configurar <a href="https://www.df8ry.de/htmlen/home/%F0%9F%8F%A1welcome.htm" target="_blank" rel="noopener">CSVUserlistBrowser</a> para usarlo con SDR#. Este programa, desarrollado por Heinrich Emmerl (DF8RY), nos permite descargar y visualizar bases de datos de frecuencias de estaciones de radiodifusión de forma sencilla, y además nos permite sintonizar dichas frecuencias en SDR# simplemente haciendo click.</p>
<a id="more"></a>

<h2 id="Instalacion-y-configuracion"><a href="#Instalacion-y-configuracion" class="headerlink" title="Instalación y configuración"></a>Instalación y configuración</h2><p>Los pasos para instalar y configurar CSVUserlistBrowser son los siguientes:</p>
<ol>
<li>Descargamos CSVUserlistBrowser desde el siguiente enlace:</li>
</ol>
<p><a href="https://www.df8ry.de/htmlen/csvub/CSVUserlistBrowser.zip" target="_blank" rel="noopener"><center>https://www.df8ry.de/htmlen/csvub/CSVUserlistBrowser.zip</center></a></p>
<ol start="2">
<li>Extraemos el contenido del archivo ZIP y ejecutamos <strong><em>CSVUserlistBrowser.exe</em></strong>. En la ventana que aparece marcamos el programa con el que queremos comunicarnos (en nuestro caso SDR#) y hacemos click en <strong>OK</strong>.</li>
</ol>
<img src="/2020/05/10/identificacion-estaciones-csvuserlistbrowser/CSVUserlistBrowser-select.png" class="" title="CSVUserlistBrowser">

<ol start="3">
<li>El programa del paso anterior nos genera un nuevo ejecutable para cada programa que hemos seleccionado. En este caso nos habrá generado el nuevo ejecutable <strong><em>SDRSHARP-CSVUserlistBrowser.exe</em></strong>.</li>
</ol>
<img src="/2020/05/10/identificacion-estaciones-csvuserlistbrowser/CSVUserlistBrowser-SDRSHARP.png" class="" width="900" title="CSVUserlistBrowser">

<ol start="4">
<li>Vamos ahora a introducir nuestras coordenadas para poder descargar las bases de datos de nuestra zona. Para ello hacemos click en el menú <strong>Tools</strong> y en <strong>QTH manager</strong>. En esta ventana introducimos nuestras coordenadas. Para finalizar guardamos haciendo click en <strong>Save details</strong> y cerramos en <strong>Close/Cancel</strong>.</li>
</ol>
<img src="/2020/05/10/identificacion-estaciones-csvuserlistbrowser/CSVUserlistBrowser-QTH-Manager.png" class="" width="700" title="CSVUserlistBrowser">

<ol start="5">
<li><p>El siguiente paso es descargar las bases de datos de frecuencias. Para ello hacemos click en el menú <strong>Web</strong> y en <strong>Downloader/Converter</strong>. En esta ventana tendremos que hacer click en los botones de <strong>Download</strong> para descargar cada una de las bases de datos.</p>
<img src="/2020/05/10/identificacion-estaciones-csvuserlistbrowser/CSVUserlistBrowser-Downloader.png" class="" title="CSVUserlistBrowser">
<p>Una vez descargadas, hacemos click en <strong>Close</strong>.<br>Estas bases de datos se actualizan regularmente, por lo que tendremos que repetir la descarga para tener siempre los datos actualizados.<br>Las URLs de descarga también se actualizan. Podemos consultar las actuales en <a href="https://www.df8ry.de/htmlen/csvub/%F0%9F%91%B6firststeps.htm" target="_blank" rel="noopener">df8ry.de</a>.</p>
</li>
<li><p>El último paso es cargar las bases de datos en el programa para poder usarlas. Para cargarlas hacemos click en el menú <strong>File</strong>, <strong>Open CSV userlist</strong> y seleccionamos el archivo que queramos cargar.</p>
</li>
</ol>
<img src="/2020/05/10/identificacion-estaciones-csvuserlistbrowser/CSVUserlistBrowser-cargada.png" class="" width="900" title="CSVUserlistBrowser">

<ol start="7">
<li>Para cargar otra lista, hacemos click en el menú <strong>View list</strong> y seleccionamos una posición libre. Después repetimos el paso anterior para cargar la lista. Si queremos que al iniciar el programa se nos muestra una base de datos u otra, podemos indicarlo en el menú <strong>Autoload</strong>.</li>
</ol>
<h2 id="Conexion-con-SDR"><a href="#Conexion-con-SDR" class="headerlink" title="Conexión con SDR#"></a>Conexión con SDR#</h2><p>SDR# se comunica con CSVUserlistBrowser mediante un <em>plugin</em>. Este plugin viene en archivo ZIP que nos descargamos en el primer paso del apartado anterior.<br>Dentro del directorio extraído encontramos el directorio <strong><em>Plugins</em></strong>, y dentro de este tendremos un directorio que contiene el archivo DLL correspondiente a la versión de SDR# que estemos usando. Es importante elegir la versión correcta para que funcione.</p>
<p>Una vez tengamos clara la versión a instalar, procedemos a instalar el <em>plugin</em> en SDR# de la forma habitual:</p>
<ol>
<li><p>Copiar el archivo <strong><em>SDRSharp.DF8RYDatabridge.dll</em></strong> dentro del directorio de instalación de SDR#.</p>
</li>
<li><p>Insertamos la siguiente línea dentro del archivo <em><strong>Plugins.xml</strong></em> que encontraremos dentro del directorio de instalación de SDR#.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"DF8RYDatabridge"</span> <span class="attr">value</span>=<span class="string">"SDRSharp.DF8RYDatabridge.DF8RYDatabridgePlugin,SDRSharp.DF8RYDatabridge"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<img src="/2020/05/10/identificacion-estaciones-csvuserlistbrowser/sdr_sharp.png" class="" width="900" title="Plugin CSVUserlistBrowser">


<h2 id="Funcionamiento"><a href="#Funcionamiento" class="headerlink" title="Funcionamiento"></a>Funcionamiento</h2><p>Para poder controlar las frecuencias desde CSVUserlistBrowser, tenemos que marcar <strong>Enable RX1</strong> en el plugin de SDR#. Ahora cuando seleccionemos una frecuencia haciendo doble click en CSVUserlistBrowser, se cambiará de forma automática en SDR#.</p>
<img src="/2020/05/10/identificacion-estaciones-csvuserlistbrowser/sdr_sharp_2.png" class="" width="900" title="SDR# y CSVUserlistBrowser">
]]></content>
      <tags>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Instalar receptor SDR online con OpenWebRX</title>
    <url>/2020/08/13/instalacion-openwebrx/</url>
    <content><![CDATA[<p><a href="https://www.openwebrx.de/" target="_blank" rel="noopener">OpenWebRX</a> es un software de recepción de señales de radio mediante dispositivos SDR que opera desde una interfaz web. Esto permite visualizar y procesar señales en tiempo real desde cualquier sitio, simplemente accediendo desde un navegador web.</p>
<p>Este proyecto <em>Open Source</em> nació en 2015 de mano de András Retzler (HA7ILM). Pero a finales de 2019, el autor abandonó el proyecto y es cuando <a href="https://github.com/jketterl" target="_blank" rel="noopener">Jakob Ketterl</a> retomó el desarrollo del proyecto añadiendo nuevas funcionalidades y mejorando el software. El proyecto comenzó a ganar popularidad y cuenta actualmente con un gran número de colaboradores.</p>
<p>En este artículo veremos cómo instalar OpenWebRX en una Raspberry Pi usando su código fuente. Existen otras opciones disponibles para instalar este software, como imágenes para tarjetas SD, paquetes, imágenes para Docker, pero presentan algunas carencias o bien son más complejas. El proceso de instalación manual que vamos a seguir es similar para cualquier distribución Linux, lo que nos aporta más posibilidades.</p>
<a id="more"></a>

<img src="/2020/08/13/instalacion-openwebrx/openwebrx.jpg" class="" width="900" title="OpenWebRX">

<h2 id="Instalar-dependencias-de-instalacion"><a href="#Instalar-dependencias-de-instalacion" class="headerlink" title="Instalar dependencias de instalación"></a>Instalar dependencias de instalación</h2><p>Para poder compilar e instalar las librerías necesarias necesitamos una serie de dependencias. Para instalarlas ejecutamos los siguientes comandos:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install git build-essential cmake libfftw3-dev python3 python3-setuptools rtl-sdr netcat libitpp-dev libsndfile-dev librtlsdr-dev automake autoconf libtool pkg-config</span><br></pre></td></tr></table></figure>

<h2 id="Instalar-librerias"><a href="#Instalar-librerias" class="headerlink" title="Instalar librerías"></a>Instalar librerías</h2><h3 id="Instalar-CSDR"><a href="#Instalar-CSDR" class="headerlink" title="Instalar CSDR"></a>Instalar CSDR</h3><p><em>CSDR</em> es la librería encargada de gestionar el dispositivo SDR. Siguiendo los pasos expuestos a continuación podremos compilarla e instalarla.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;jketterl&#x2F;csdr.git</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd csdr</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoreconf -i</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;configure</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<h3 id="Instalar-OWRX-Connector"><a href="#Instalar-OWRX-Connector" class="headerlink" title="Instalar OWRX Connector"></a>Instalar OWRX Connector</h3><p><em>OWRX Connector</em> es la librería encargada de conectar la interfaz del SDR con OpenWebRX. Instalamos siguiendo los pasos descritos a continuación.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;jketterl&#x2F;owrx_connector.git</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd owrx_connector</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd build</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..&#x2F;..</span><br></pre></td></tr></table></figure>

<h3 id="Instalar-js8py"><a href="#Instalar-js8py" class="headerlink" title="Instalar js8py"></a>Instalar js8py</h3><p>Librería para decodificar la salida de JS8Call.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;jketterl&#x2F;js8py.git</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd js8py</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo python3 setup.py install</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<h3 id="Instalar-SoapySDR-Opcional"><a href="#Instalar-SoapySDR-Opcional" class="headerlink" title="Instalar SoapySDR (Opcional)"></a>Instalar SoapySDR (Opcional)</h3><p>Si vamos a utilizar un dispositivo distinto del RTL-SDR tendremos que instalar SoapySDR para poder usarlo.<br>Los pasos para su instalación son los siguientes:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libsoapysdr0.6 libsoapysdr-dev soapysdr-tools soapysdr-module-all</span><br></pre></td></tr></table></figure>

<p>Si no encuentra la librería “libsoapysdr0.6”, reemplazar por “libsoapysdr0.7”.</p>
<h2 id="Clonar-repositorio-de-OpenWebRX"><a href="#Clonar-repositorio-de-OpenWebRX" class="headerlink" title="Clonar repositorio de OpenWebRX"></a>Clonar repositorio de OpenWebRX</h2><p>Descargamos la última versión estable disponible. Consultar el listado de versiones <a href="https://github.com/jketterl/openwebrx/tags" target="_blank" rel="noopener">aquí</a>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b 0.19.1 https:&#x2F;&#x2F;github.com&#x2F;jketterl&#x2F;openwebrx.git</span><br></pre></td></tr></table></figure>

<h2 id="Configuracion"><a href="#Configuracion" class="headerlink" title="Configuración"></a>Configuración</h2><p>El archivo de configuración se encuentra dentro del repositorio que acabamos de clonar. Para editarlo lo abrimos con el editor:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nano config_webrx.py</span><br></pre></td></tr></table></figure>

<p>Este archivo contiene muchos ajustes que podemos modificar. El ajuste principal que vamos a ver es el de configurar los dispositivos SDR. Para ello abrimos el archivo y buscamos el siguiente fragmento:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">sdrs &#x3D; &#123;</span><br><span class="line">    &quot;rtlsdr&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;RTL-SDR USB Stick&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;rtl_sdr&quot;,</span><br><span class="line">        &quot;ppm&quot;: 0,</span><br><span class="line">        # you can change this if you use an upconverter. formula is:</span><br><span class="line">        # center_freq + lfo_offset &#x3D; actual frequency on the sdr</span><br><span class="line">        # &quot;lfo_offset&quot;: 0,</span><br><span class="line">        &quot;profiles&quot;: &#123;</span><br><span class="line">            &quot;70cm&quot;: &#123;</span><br><span class="line">                &quot;name&quot;: &quot;70cm Relais&quot;,</span><br><span class="line">                &quot;center_freq&quot;: 438800000,</span><br><span class="line">                &quot;rf_gain&quot;: 30,</span><br><span class="line">                &quot;samp_rate&quot;: 2400000,</span><br><span class="line">                &quot;start_freq&quot;: 439275000,</span><br><span class="line">                &quot;start_mod&quot;: &quot;nfm&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;2m&quot;: &#123;</span><br><span class="line">                &quot;name&quot;: &quot;2m komplett&quot;,</span><br><span class="line">                &quot;center_freq&quot;: 145000000,</span><br><span class="line">                &quot;rf_gain&quot;: 30,</span><br><span class="line">                &quot;samp_rate&quot;: 2400000,</span><br><span class="line">                &quot;start_freq&quot;: 145725000,</span><br><span class="line">                &quot;start_mod&quot;: &quot;nfm&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Ahora lo editamos con los datos de nuestro/os dispositivos conectados. A continuación se muestra un breve descripción de esta configuración:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdrs &#x3D; &#123;</span><br><span class="line">    &quot;[NOMBRE_DEL_AJUSTE]&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: &quot;[NOMBRE_DEL_DISPOSITIVO: Nombre descriptivo que se mostrará en el selector.]&quot;,</span><br><span class="line">        &quot;type&quot;: &quot;[TIPO_DISPOSITIVO: rtl_sdr, rtl_sdr_soapy, sdrplay, hackrf, airspy, airspyhf, fifi_sdr, perseussdr, lime_sdr, pluto_sdr,soapy_remote.]&quot;,</span><br><span class="line">        &quot;device&quot;: &quot;[NUMERO_SERIE: Añadir en caso de que tengamos varios dispositivos RTL-SDR.]&quot;,</span><br><span class="line">        &quot;ppm&quot;: [VALOR_PPM],</span><br><span class="line">        &quot;lfo_offset&quot;: [VALOR_DESPLAZAMIENTO: Añadir si usamos Up&#x2F;Down converter.],</span><br><span class="line">        &quot;profiles&quot;: &#123;</span><br><span class="line">            &quot;[NOMBRE_DEL_PERFIL]&quot;: &#123;</span><br><span class="line">                &quot;name&quot;: &quot;[DESCRIPCION: Nombre que se mostrará en el selector.]&quot;,</span><br><span class="line">                &quot;center_freq&quot;: [FRECUENCIA_CENTRAL],</span><br><span class="line">                &quot;rf_gain&quot;: [GANANCIA_DEL_SDR: Ganancia para esta frecuencia.],</span><br><span class="line">                &quot;samp_rate&quot;: [SAMPLE_RATE],</span><br><span class="line">                &quot;start_freq&quot;: [FRECUENCIA_DE_INICIO],</span><br><span class="line">                &quot;start_mod&quot;: &quot;[MODO_DE_INICIO]&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Modificamos el ajuste añadiendo o quitando tantos dispositivos y perfiles como queramos.</p>
<h2 id="Instalar-como-servicio"><a href="#Instalar-como-servicio" class="headerlink" title="Instalar como servicio"></a>Instalar como servicio</h2><p>El último paso es instalar OpenWebRX como servicio para que se inicie de forma automática al iniciar el sistema. Para ello vamos a añadir un nuevo servicio:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;openwebrx.service</span><br></pre></td></tr></table></figure>

<p>Añadimos lo siguiente, modificando si fuese necesario:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;OpenWebRX</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">StartLimitIntervalSec&#x3D;0</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">Restart&#x3D;always</span><br><span class="line">RestartSec&#x3D;1</span><br><span class="line">User&#x3D;pi</span><br><span class="line">WorkingDirectory&#x3D;&#x2F;home&#x2F;pi&#x2F;openwebrx</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3 &#x2F;home&#x2F;pi&#x2F;openwebrx&#x2F;openwebrx.py</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>

<p>Activamos para que se inicie de forma automática:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable openwebrx</span><br></pre></td></tr></table></figure>

<p>Iniciamos el servicio:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start openwebrx</span><br></pre></td></tr></table></figure>

<p>Ahora ya podemos acceder desde cualquier navegador introduciendo la dirección IP de la Raspberry Pi y el puerto 8073 (podemos cambiarlo en los ajustes):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;[DIRECCION_IP:8073]</span><br></pre></td></tr></table></figure>

<h2 id="Instalar-paquetes-adicionales"><a href="#Instalar-paquetes-adicionales" class="headerlink" title="Instalar paquetes adicionales"></a>Instalar paquetes adicionales</h2><p>Tenemos la posibilidad de añadir nuevos paquetes a OpenWebRX para decodificar ciertos modos digitales:</p>
<ul>
<li>JS8Call.</li>
<li>APRS.</li>
<li>WSJT-X (FT8, FT4, WSPR, JT65, JT9).</li>
<li>Voz digital (DMR, YSF).</li>
</ul>
<p>La guía de instalación de todos estos paquetes se encuentra en el manual oficial de instalación de OpenWebRX del que se ha obtenido la información para este artículo:</p>
<p><a href="https://github.com/jketterl/openwebrx/wiki/Manual-Package-installation-(including-digital-voice)" target="_blank" rel="noopener"><center>https://github.com/jketterl/openwebrx/wiki/Manual-Package-installation-(including-digital-voice)</center></a></p>
]]></content>
      <tags>
        <tag>RTL-SDR</tag>
        <tag>OpenWebRX</tag>
        <tag>Raspberry Pi</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Instalación de dispositivos RTL-SDR en Raspberry Pi</title>
    <url>/2020/04/10/instalacion-rtlsdr-raspberrypi/</url>
    <content><![CDATA[<p>En este tutorial veremos como instalar nuestro dispositivo RTL-SDR en una Raspberry Pi. Para la realización del mismo se ha empleado una Raspberry Pi 3 con la distribución Raspbian Buster Lite, si bien estos pasos son similares para cualquier distribución Linux.</p>
<a id="more"></a>

<img src="/2020/04/10/instalacion-rtlsdr-raspberrypi/raspberry-pi-3.png" class="" title="Raspberry Pi 3">

<p>Vamos a instalar los drivers y librerias necesarias para usar el dispositivo SDR. Para ello ejecutamos el siguiente comando:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install rtl-sdr librtlsdr-dev</span><br></pre></td></tr></table></figure>

<p>Una vez instalado el dispositivo le daremos permisos a los usuarios no <em>root</em> para poder usar el dispositivo. Para ello seguiremos los siguientes pasos para crear una regla <em>udev</em>.</p>
<ol>
<li>Con el dispositivo SDR conectado, ejecutamos el siguiente comando para obtener la lista de dispositivos USB conectados:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Buscamos en la lista el dispositivo SDR y nos fijamos en los identificadores de fabricante y de dispositivo. En este caso son <strong>0bda</strong> y <strong>2838</strong> respectivamente.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bus 001 Device 004: ID 0bda:2838 Realtek Semiconductor Corp. RTL2838 DVB-T</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Ahora creamos un archivo de reglas nuevo:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;rtl-sdr.rules</span><br></pre></td></tr></table></figure>

<p>Y añadimos la siguiente regla modificando los identificadores si fuese necesario para que correspondan con los obtenidos en el paso anterior:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SUBSYSTEMS==<span class="string">"usb"</span>, ATTRS&#123;idVendor&#125;==<span class="string">"0bda"</span>, ATTRS&#123;idProduct&#125;==<span class="string">"2838"</span>, MODE:=<span class="string">"0666"</span></span><br></pre></td></tr></table></figure>

<p>Por último desconectamos el dispostivo SDR y lo volvemos a conectar para que se aplique la regla y ejecutamos el siguiente comando para comprobar que el dispositivo funciona correctamente:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtl_test</span><br></pre></td></tr></table></figure>

<p>Si todo está correctamente instalado veremos una salida como la siguiente:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Found 1 device(s):</span><br><span class="line">  0:  Realtek, RTL2838UHIDIR, SN: 82020715</span><br><span class="line"></span><br><span class="line">Using device 0: Generic RTL2832U OEM</span><br><span class="line">Detached kernel driver</span><br><span class="line">Found Rafael Micro R820T tuner</span><br><span class="line">Supported gain values (29): 0.0 0.9 1.4 2.7 3.7 7.7 8.7 12.5 14.4 15.7 16.6 19.7 20.7 22.9 25.4 28.0 29.7 32.8 33.8 36.4 37.2 38.6 40.2 42.1 43.4 43.9 44.5 48.0 49.6</span><br><span class="line">[R82XX] PLL not locked!</span><br><span class="line">Sampling at 2048000 S&#x2F;s.</span><br><span class="line"></span><br><span class="line">Info: This tool will continuously read from the device, and report if</span><br><span class="line">samples get lost. If you observe no further output, everything is fine.</span><br><span class="line"></span><br><span class="line">Reading samples in async mode...</span><br><span class="line">Allocating 15 zero-copy buffers</span><br><span class="line">lost at least 140 bytes</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>SDRSharp</tag>
        <tag>RTL-SDR</tag>
        <tag>Raspberry Pi</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Instalación de dispositivos RTL-SDR en macOS</title>
    <url>/2020/06/14/instalacion-rtlsdr-macos/</url>
    <content><![CDATA[<p>En este tutorial veremos como instalar nuestro dispositivo RTL-SDR en macOS. También veremos como instalar CubicSDR para poder usarlo.</p>
<a id="more"></a>

<h2 id="Instalacion-de-los-drivers"><a href="#Instalacion-de-los-drivers" class="headerlink" title="Instalación de los drivers"></a>Instalación de los drivers</h2><p>Para poder instalar los drivers necesitamos tener instalado previamente un gestor de paquetes. El más conocido y recomendado es <strong>Homebrew</strong>. Si no lo tenemos aún instalado podemos seguir los pasos descritos en su página web:</p>
<p><a href="https://brew.sh/index_es" target="_blank" rel="noopener"><center>https://brew.sh/index_es</center></a></p>
<p>Si ya lo tenemos instalado, procedemos a instalar los drivers ejecutando el siguiente comando desde la consola.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install rtl-sdr</span><br></pre></td></tr></table></figure>

<p>Con el dispositivo SDR conectado, ejecutamos el siguiente comando para comprobar que se ha instalado correctamente.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtl_test</span><br></pre></td></tr></table></figure>

<p>Si todo ha ido bien, tendremos una salida como la siguiente.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Found 1 device(s):</span><br><span class="line">  0:  Realtek, RTL2838UHIDIR, SN: 02201602</span><br><span class="line"></span><br><span class="line">Using device 0: Generic RTL2832U OEM</span><br><span class="line">Found Rafael Micro R820T tuner</span><br><span class="line">Supported gain values (29): 0.0 0.9 1.4 2.7 3.7 7.7 8.7 12.5 14.4 15.7 16.6 19.7 20.7 22.9 25.4 28.0 29.7 32.8 33.8 36.4 37.2 38.6 40.2 42.1 43.4 43.9 44.5 48.0 49.6</span><br><span class="line">[R82XX] PLL not locked!</span><br><span class="line">Sampling at 2048000 S&#x2F;s.</span><br><span class="line"></span><br><span class="line">Info: This tool will continuously read from the device, and report if</span><br><span class="line">samples get lost. If you observe no further output, everything is fine.</span><br><span class="line"></span><br><span class="line">Reading samples in async mode...</span><br></pre></td></tr></table></figure>

<h2 id="Instalacion-de-CubicSDR"><a href="#Instalacion-de-CubicSDR" class="headerlink" title="Instalación de CubicSDR"></a>Instalación de CubicSDR</h2><p><a href="https://cubicsdr.com/" target="_blank" rel="noopener">CubicSDR</a> es una aplicación multiplataforma para SDR que nos permite navegar por el espectro radioeléctrico de forma visual y demodular señales de forma sencilla.</p>
<p>Para descargar CubicSDR debemos ir a su repositorio en GitHub y descargar la última versión disponible para macOS. Para ello accedemos su repositorio a través del siguiente enlace y descargamos el instalador para macOS.</p>
<p><a href="https://github.com/cjcliffe/CubicSDR/releases" target="_blank" rel="noopener"><center>https://github.com/cjcliffe/CubicSDR/releases</center></a></p>
<img src="/2020/06/14/instalacion-rtlsdr-macos/download_cubicsdr.png" class="" width="700" title="Descarga de CubicSDR">

<p>Una vez descargado, lo ejecutamos y en la ventana que aparece arrastramos el binario a nuestro directorio de aplicaciones.</p>
<img src="/2020/06/14/instalacion-rtlsdr-macos/install_cubicsdr.png" class="" width="700" title="Instalación de CubicSDR">

<p>Ahora ejecutamos CubicSDR desde las aplicaciones instaladas para iniciarlo. Nos mostrará una ventana como la siguiente en la que debemos seleccionar nuestro dispositivo SDR y hacemos click en <em>Start</em>.</p>
<img src="/2020/06/14/instalacion-rtlsdr-macos/cubicsdr_devices.png" class="" width="700" title="Configuración de CubicSDR">

<p>Finalmente, CubicSDR se iniciará y ya podremos utilizarlo.</p>
<img src="/2020/06/14/instalacion-rtlsdr-macos/cubicsdr.png" class="" width="900" title="CubicSDR">

<p>CubicSDR también nos permite sacar el audio demodulado para poder usarlo con otros programas. Podemos seguir los pasos descritos en el tutorial <a href="/2020/01/21/instalacion-virtual-cable-audio/">“Instalación de cable de audio virtual”</a> para configurarlo.</p>
]]></content>
      <tags>
        <tag>RTL-SDR</tag>
        <tag>macOS</tag>
        <tag>CubicSDR</tag>
      </tags>
  </entry>
  <entry>
    <title>Instalación de dispositivos RTL-SDR en Windows</title>
    <url>/2020/01/19/instalacion-rtlsdr-windows/</url>
    <content><![CDATA[<p>En este tutorial vamos a ver como instalar nuestro nuevo dispositivo RTL-SDR en Windows 10.</p>
<p>Existen varias alternativas para Windows, pero en este tutorial vamos a instalar y configurar SDR# (SDR Sharp), ya que es el más conocido y utilizado.</p>
<a id="more"></a>

<h2 id="Instalacion-de-SDR"><a href="#Instalacion-de-SDR" class="headerlink" title="Instalación de SDR#"></a>Instalación de SDR#</h2><p>El primer paso es descargar el software que necesitamos para poder usar nuestro SDR. Para ello nos vamos a la web de AIRSPY para descargar la última versión disponible de SDR# haciendo click en el siguiente enlace:</p>
<p><a href="https://airspy.com/download/" target="_blank" rel="noopener"><center>https://airspy.com/download/</center></a></p>
<img src="/2020/01/19/instalacion-rtlsdr-windows/descarga.jpg" class="" title="Descarga de SDR#">

<p>Hacemos click en <em>Download</em> y esperamos a que se descargue.<br>Una vez descargado el archivo ZIP, extraemos su contenido en el directorio deseado. En este ejemplo vamos a usar el directorio <em>C:/SDR</em>.</p>
<h2 id="Instalacion-de-los-drivers"><a href="#Instalacion-de-los-drivers" class="headerlink" title="Instalación de los drivers"></a>Instalación de los drivers</h2><p>El siguiente paso es descargar los drivers para nuestro dispositivo RTL-SDR. Para ello, el propio SDR# trae un script que nos descarga estos drivers directamente. Solo tenemos que ejecutar el archivo <strong>install-rtlsdr.bat</strong> que encontraremos en el directorio en el que acabamos de extraer SDR#.</p>
<img src="/2020/01/19/instalacion-rtlsdr-windows/bat.jpg" class="" title="install-rtlsdr.bat">

<p>Una vez el script termine nos pedirá que pulsemos una tecla para finalizar.</p>
<p>Por defecto, Windows nos instala sus propios drivers para nuestro dispositivo RTL-SDR. Estos drivers no nos sirven para poder utilizarlo con SDR# por lo que tendremos que sustituirlos por otros.<br>Para ello utilizaremos el instalador <strong>Zadig</strong>. Este ejecutable se descarga automáticamente al ejecutar el script del paso anterior, por lo que solo tendremos que ir al directorio antes mencionado y ejecutar (como Administrador) el archivo <strong>zadig.exe</strong>.</p>
<img src="/2020/01/19/instalacion-rtlsdr-windows/zadig1.jpg" class="" title="zadig.exe">

<p>En la ventana del instalador seleccionamos <strong>Options</strong> y marcamos <strong>List All Devices</strong>.</p>
<img src="/2020/01/19/instalacion-rtlsdr-windows/zadig3.jpg" class="" title="Zadig list devices">

<p>Ahora tendremos que seleccionar nuestro dispositivo en el listado.<br>Tenemos que asegurarnos de que el dispositivo que seleccionemos se corresponde con el RTL-SDR. De lo contrario vamos a reemplazar el driver de otro dispositivo y dejará de funcionar.</p>
<img src="/2020/01/19/instalacion-rtlsdr-windows/zadig4.jpg" class="" title="Zadig replace">

<p>Una vez lo tengamos seleccionado correctamente, hacemos click en <strong>Replace Driver</strong> y esperamos a que se instalen los nuevos drivers.</p>
<img src="/2020/01/19/instalacion-rtlsdr-windows/zadig5.jpg" class="" title="Zadig instalado">

<h2 id="Configuracion-de-SDR"><a href="#Configuracion-de-SDR" class="headerlink" title="Configuración de SDR#"></a>Configuración de SDR#</h2><p>Ya tenemos nuestro dispositivo conectado e instalado. Es el turno ahora de decirle a SDR# que utilice nuestro dispositivo.<br>Para ello vamos al directorio en el que hemos instalado SDR# y ejecutamos <strong>SDRSharp.exe</strong> para iniciar el programa.</p>
<p>Una vez abierto, hacemos click en <strong>Source</strong> y seleccionamos <strong>RTL-SDR (USB)</strong>.</p>
<img src="/2020/01/19/instalacion-rtlsdr-windows/sdrsharp_source.jpg" class="" title="Seleccionando dispositivo">

<p>Después de haber seleccionado nuestro dispositivo, tenemos que editar sus ajustes. Para ello hacemos click en el icono de ajustes para mostrar la ventana de configuración.</p>
<img src="/2020/01/19/instalacion-rtlsdr-windows/sdrsharp.jpg" class="" title="Ajustes">

<p>En esta ventana encontramos las siguientes opciones:</p>
<img src="/2020/01/19/instalacion-rtlsdr-windows/sdrsharp_config.jpg" class="" title="RTL-SDR Controller">

<table>
<thead>
<tr>
<th>Ajuste</th>
<th>Recomendado</th>
<th>Descripción</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Device</strong></td>
<td></td>
<td>Nos permite indicarle el dispositivo RTL-SDR que utilizaremos. Si no hemos instalado los drivers del paso anterior correctamente, no nos aparecerá ninguno disponible.</td>
</tr>
<tr>
<td><strong>Sample Rate</strong></td>
<td>2.4 MSPS</td>
<td>Permite elegir el ancho de banda que nos mostrará por pantalla. Lógicamente, a mayor valor, mayor consumo de recursos de nuestro PC. Por lo que si tenemos un PC poco potente, debemos seleccionar un valor más bajo.</td>
</tr>
<tr>
<td><strong>Sampling Mode</strong></td>
<td>Quadrature Sampling</td>
<td>Permite elegir el modo de muestreo.</td>
</tr>
<tr>
<td><strong>Offset tunning</strong></td>
<td>R820T: Desactivado   E4000: Activado</td>
<td>Solo es necesario para los dispositivos basados en el chip E4000.</td>
</tr>
<tr>
<td><strong>RTL AGC</strong></td>
<td>Desactivado</td>
<td>Activa el control automático de ganancia del chip RTL2832U.</td>
</tr>
<tr>
<td><strong>Tuner AGC</strong></td>
<td>Desactivado</td>
<td>Activa el control automático de ganancia del sintonizador del dispositivo.</td>
</tr>
<tr>
<td><strong>RF Gain</strong></td>
<td></td>
<td>Permite ajustar la ganancia manualmente. En el siguiente punto veremos como ajustarla correctamente.</td>
</tr>
<tr>
<td><strong>Frequency correction (ppm)</strong></td>
<td></td>
<td>Permite corregir la variación de la frecuencia que tienen la mayoría de dispositivos. Esta variación se debe al oscilador de baja calidad con el que normalmente vienen. Para establecer este valor, tendremos que sintonizar una frecuencia conocida y ajustarlo manualmente.</td>
</tr>
</tbody></table>
<p>Con todo ya configurado, solo queda pulsar el botón de <strong>Start/Stop</strong> para empezar a recibir.</p>
<img src="/2020/01/19/instalacion-rtlsdr-windows/sdrsharp_running.jpg" class="" title="SDR# recibiendo">

<h2 id="Ajuste-de-la-ganancia"><a href="#Ajuste-de-la-ganancia" class="headerlink" title="Ajuste de la ganancia"></a>Ajuste de la ganancia</h2><p>En este último paso vamos a ajustar la ganancia de nuestro dispositivo manualmente. Como hemos visto anteriormente, el ajuste de la ganancia se puede dejar para que el dispositivo lo haga automáticamente. El problema es que este ajuste muy pocas veces se hace correctamente, por lo que es muy recomendable hacerlo manualmente. Para ello sintonizamos cualquier señal en la frecuencia para la que vamos a ajustar la ganancia y abrimos los ajustes del dispositivo.<br>Ahora el objetivo es ajustar el valor de <strong>RF Gain</strong> hasta que consigamos el mejor valor de SNR (Signal to Noise Ratio).</p>
<img src="/2020/01/19/instalacion-rtlsdr-windows/ganancia.jpg" class="" title="Ajuste de la ganancia manualmente">

<p>Una vez tengamos la ganancia ajustada, ya tendremos listo nuestro dispositivo SDR.</p>
]]></content>
      <tags>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
        <tag>RTL-SDR</tag>
      </tags>
  </entry>
  <entry>
    <title>Instalación de estación terrestre con SatNOGS (II)</title>
    <url>/2020/04/27/instalacion-satnogs-ansible/</url>
    <content><![CDATA[<p>En el artículo anterior <a href="https://sdr-es.com/2020/04/24/instalacion-satnogs/">“Instalación de estación terrestre con SatNOGS”</a> vimos como crear una estación terrestre para el seguimiento de satélites usando una Raspberry Pi, y para ello utilizamos la imagen ya generada para el cliente de SatNOGS.<br>En este artículo veremos como realizar la instalación del cliente SatNOGS en una Raspberry Pi previamente configurada, en la que ya tenemos otros servicios corriendo.</p>
<a id="more"></a>


<p>Si bien este artículo se centra en la instalación en una Raspberry Pi, es posible realizar la instalación en otros dispositivos Linux mediante este mismo procedimiento. El <em>playbook</em> de Ansible que vamos a utilizar es compatible con las siguientes distribuciones y versiones:</p>
<ul>
<li><strong>Debian:</strong> <em>stretch</em>, <em>buster</em>.</li>
<li><strong>Raspbian:</strong> <em>stretch</em>, <em>buster</em>.</li>
</ul>
<h2 id="Instalacion-de-Ansible"><a href="#Instalacion-de-Ansible" class="headerlink" title="Instalación de Ansible"></a>Instalación de Ansible</h2><p>Lo primero que haremos será instalar la última versión de Ansible. Para ello seguimos los siguientes pasos:</p>
<ol>
<li>Añadir el repositorio de Ansible.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;deb http:&#x2F;&#x2F;ppa.launchpad.net&#x2F;ansible&#x2F;ansible&#x2F;ubuntu trusty main&quot; | sudo tee -a &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Añadir la clave del repositorio.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 93C4A3FD7BB9C367</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Actualizar lista de repositorios.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Instalar Ansible.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y ansible</span><br></pre></td></tr></table></figure>

<h2 id="Instalacion-del-cliente-Ansible-de-SatNOGS"><a href="#Instalacion-del-cliente-Ansible-de-SatNOGS" class="headerlink" title="Instalación del cliente Ansible de SatNOGS"></a>Instalación del cliente Ansible de SatNOGS</h2><p>A continuación vamos a descargar e instalar el instalador del cliente SatNOGS.</p>
<ol>
<li>Instalamos las dependencias que vamos a necesitar:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y git needrestart</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Descargamos el repositorio:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b stable https:&#x2F;&#x2F;gitlab.com&#x2F;librespacefoundation&#x2F;satnogs&#x2F;satnogs-client-ansible.git</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Accedemos a la carpeta descargada:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd satnogs-client-ansible</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Copiamos y renombramos el siguiente directorio:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r production.dist production</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Ahora editamos el archivo <code>hosts</code> con nuestros datos de conexión SSH a la Raspberry Pi:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nano production&#x2F;inventory&#x2F;hosts</span><br></pre></td></tr></table></figure>

<p>Debemos editar el <em>host</em>, el usuario y la clave:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">  hosts:</span><br><span class="line">    satnogs:</span><br><span class="line">      ansible_host: &#39;localhost&#39;</span><br><span class="line">      ansible_user: &#39;pi&#39;</span><br><span class="line">      ansible_ssh_pass: &#39;raspberry&#39;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Comprobamos la conexión SSH:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh pi@localhost true</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Por último ejecutamos el <em>playbook</em>:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ansible-playbook -i production&#x2F;inventory -K site.yml</span><br></pre></td></tr></table></figure>

<p>La instalación tardará unos minutos (pueden ser bastantes dependiendo de nuestra conexión y la CPU de la Raspberry Pi) y al finalizar mostrará un mensaje como el siguiente:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Play recap -</span><br><span class="line">  satnogs                    : ok&#x3D;121  changed&#x3D;49   unreachable&#x3D;0    failed&#x3D;0    rescued&#x3D;0    ignored&#x3D;0</span><br></pre></td></tr></table></figure>

<h2 id="Configuracion-de-SatNOGS"><a href="#Configuracion-de-SatNOGS" class="headerlink" title="Configuración de SatNOGS"></a>Configuración de SatNOGS</h2><p>Los pasos para la configuración del cliente son idénticos a los descritos en el artículo anterior en este mismo apartado.</p>
<p>La única observación es que ahora al tener más de un dispositivo SDR conectado, debemos indicar cual de ellos debe utilizar.<br>Necesitaremos el número de serie del dispositivo para diferenciarlos. Para extraerlo usamos la herramienta <code>rtl_test</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ rtl_test</span><br><span class="line">Found 2 device(s):</span><br><span class="line">  0:  Realtek, RTL2838UHIDIR, SN: 02201602</span><br><span class="line">  1:  Realtek, RTL2838UHIDIR, SN: 08201703</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>En este caso vamos a utilizar el segundo dispositivo, y por lo tanto se lo debemos indicar a SatNOGS. Para ello en <strong><em>Basic configuration options</em></strong> realizaremos el siguiente cambio:</p>
<table>
<thead>
<tr>
<th>Ajuste</th>
<th>Descripción</th>
</tr>
</thead>
<tbody><tr>
<td>SATNOGS_SOAPY_RX_DEVICE</td>
<td>Dispositivo SDR que vamos a usar y número de serie: <code>driver=rtlsdr,serial=08201703</code>.</td>
</tr>
</tbody></table>
<img src="/2020/04/27/instalacion-satnogs-ansible/satnogs-config.png" class="" title="SatNOGS Setup">
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>RTL-SDR</tag>
        <tag>Raspberry Pi</tag>
        <tag>Linux</tag>
        <tag>SatNOGS</tag>
      </tags>
  </entry>
  <entry>
    <title>Instalación de estación terrestre con SatNOGS</title>
    <url>/2020/04/24/instalacion-satnogs/</url>
    <content><![CDATA[<p><a href="https://satnogs.org/" target="_blank" rel="noopener">SatNOGS</a> (Satellite Networked Open Ground Station) es una plataforma de software y hardware de código abierto con el propósito de crear una red global de estaciones terrestres de seguimiento de satélites.</p>
<p>En este artículo veremos como instalar una estación terrestre para el seguimiento de satélites de forma desatendida. Para ello vamos a utilizar un dispositivo SDR y una Raspberry Pi con el software SatNOGS.</p>
<a id="more"></a>

<h2 id="Registrar-nuestra-estacion-en-la-red"><a href="#Registrar-nuestra-estacion-en-la-red" class="headerlink" title="Registrar nuestra estación en la red"></a>Registrar nuestra estación en la red</h2><p>El primer paso será registrarnos en la red de SatNOGS para obtener nuestro identificador de estación y la <em>API key</em>.<br>Para ello vamos a la web de SatNOGS mediante el siguiente enlace:</p>
<p><a href="https://network.satnogs.org/" target="_blank" rel="noopener"><center>https://network.satnogs.org/</center></a></p>
<p>Aquí podemos ver las estaciones conectadas a la red, a las que podemos acceder para programar y revisar pases.</p>
<p>Para registrarnos, hacemos click en <em>Sign Up / Log In</em>.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs_inicio.png" class="" width="900" title="SatNOGS">

<p>A continuación introducimos nuestro correo electrónico, nombre de usuario y una contraseña. Hacemos click en <em>SIGN UP</em>.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs_registro.png" class="" title="SatNOGS Sign Up">

<p>Una vez registrados, vamos a crear una nueva estación. Para ello hacemos click en <em>Add Ground Station</em>.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs_registrado.png" class="" width="900" title="Nueva estación SatNOGS">

<p>Ahora introducimos los datos requeridos de nuestra estación.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs_crear_groundstation.png" class="" width="900" title="Datos estación SatNOGS">

<p>Cuando los tengamos correctamente introducidos, hacemos click en <strong><em>Submit</em></strong> para enviar los datos y registrar nuestra nueva estación.<br>Una vez registrada se nos mostrará una nueva página con los datos de la misma. Podemos ver que delante del nombre se nos ha asignado un identificador de estación (en este ejemplo el 1516) que debemos anotar para sucesivos pasos.</p>
<p>Ahora vamos al panel de control (<em>dashboard</em>) haciendo click en el icono de la esquina superior derecha.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs_groundstation_creada.png" class="" width="900" title="SatNOGS">

<p>Hacemos click en <em>API Key</em> y copiamos nuestro token.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs_api_key.png" class="" width="900" title="SatNOGS API Key">


<h2 id="Descargar-imagen-de-SatNOGS-para-Raspberry-Pi"><a href="#Descargar-imagen-de-SatNOGS-para-Raspberry-Pi" class="headerlink" title="Descargar imagen de SatNOGS para Raspberry Pi"></a>Descargar imagen de SatNOGS para Raspberry Pi</h2><p>Vamos ahora a preparar la Raspberry Pi. Para ello vamos a instalar la imagen que hay creada del cliente de SatNOGS y que podemos descargar desde la siguiente página:</p>
<p><a href="https://gitlab.com/librespacefoundation/satnogs/satnogs-pi-gen/-/tags" target="_blank" rel="noopener"><center>https://gitlab.com/librespacefoundation/satnogs/satnogs-pi-gen/-/tags</center></a></p>
<p>Aquí descargamos la última versión disponible.</p>
<img src="/2020/04/24/instalacion-satnogs/descarga_imagen.png" class="" width="900" title="Descarga imagen SatNOGS">

<p>Una vez descargado el archivo, extraemos la imagen y la grabamos en la tarjeta SD con el programa que tengamos para ello. En este ejemplo se ha usado <a href="https://sourceforge.net/projects/win32diskimager/" target="_blank" rel="noopener">Win32 Disk Imager</a>.</p>
<img src="/2020/04/24/instalacion-satnogs/grabar_imagen.png" class="" title="Win32 Disk Imager">


<h2 id="Configuracion-de-Raspberry-Pi"><a href="#Configuracion-de-Raspberry-Pi" class="headerlink" title="Configuración de Raspberry Pi"></a>Configuración de Raspberry Pi</h2><p>Ahora vamos a configurar algunos aspectos esenciales en nuestra Raspberry Pi.</p>
<p>Una vez que tengamos la Raspberry Pi iniciada, accedemos a ella mediante SSH (usuario <strong>“pi”</strong> y clave <strong>“raspberry”</strong>) y ejecutamos el siguiente comando:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure>

<p>Se nos muestra en pantalla el menú de la herramienta de configuración de la Raspberry Pi.</p>
<img src="/2020/04/24/instalacion-satnogs/raspi-config.png" class="" title="Configuración de Raspberry Pi">

<p>Los ajustes básicos que debemos llevar a cabo son:</p>
<ul>
<li>Cambiar la clave por defecto.</li>
<li>Configurar la zona horaria a UTC. En <em>Localisation Options</em>, <em>Change Timezone</em>, <em>None of the above</em>, <em>UTC</em>.</li>
<li>Expandir el sistema de archivos. En <em>Advanced Options</em>, primera opción:</li>
</ul>
<img src="/2020/04/24/instalacion-satnogs/raspi-config_advanced.png" class="" title="Configuración de Raspberry Pi">

<p>Por último, reiniciamos la Raspberry Pi para que se apliquen los cambios.</p>
<h2 id="Configuracion-de-SatNOGS"><a href="#Configuracion-de-SatNOGS" class="headerlink" title="Configuración de SatNOGS"></a>Configuración de SatNOGS</h2><p>Turno ahora de configurar el cliente SatNOGS. Para ello ejecutamos el siguiente comando:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo satnogs-setup</span><br></pre></td></tr></table></figure>

<p>Se mostrará el menú principal de opciones:</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs-setup.png" class="" title="SatNOGS Setup">

<p>Lo primero es actualizar la propia herramienta de configuración desde <em>Update configuration tool</em>.<br>Esta operación tardará unos minutos y nos pedirá confirmación para descargar algunos paquetes. Al finalizar nos mostrará la siguiente ventana para indicar que servicios queremos reiniciar. Debemos darle a <em>Ok</em>.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs-setup_restart.png" class="" title="SatNOGS Setup">

<p>Volvemos ahora al menú principal y vamos a <strong><em>Basic configuration options</em></strong>. Aquí vamos a introducir los datos de nuestra estación:</p>
<table>
<thead>
<tr>
<th>Ajuste</th>
<th>Descripción</th>
</tr>
</thead>
<tbody><tr>
<td>SATNOGS_API_TOKEN</td>
<td>API key obtenida anteriormente.</td>
</tr>
<tr>
<td>SATNOGS_SOAPY_RX_DEVICE</td>
<td>Dispositivo SDR que vamos a usar.<br>Para el RTL-SDR introducimos <code>driver=rtlsdr</code>.<br>Para otros dispositivos consultar en <a href="https://github.com/pothosware/SoapyRTLSDR/wiki" target="_blank" rel="noopener">https://github.com/pothosware/SoapyRTLSDR/wiki</a> (apartado <em>Modules</em>).</td>
</tr>
<tr>
<td>SATNOGS_ANTENNA</td>
<td>Para el RTL-SDR introducimos <code>RX</code>.<br>Para otros dispositivos debemos consultar el valor usando el comando <code>SoapySDRUtil --probe 2&gt;&amp;1 | grep Antennas</code>.</td>
</tr>
<tr>
<td>SATNOGS_RX_SAMP_RATE</td>
<td><em>Sample rate</em> del dispositivo.<br>Para el RTL-SDR introducimos <code>2.048e6</code>.</td>
</tr>
<tr>
<td>SATNOGS_STATION_ELEV</td>
<td>Altitud de nuestra estación.</td>
</tr>
<tr>
<td>SATNOGS_STATION_ID</td>
<td>Identificador de nuestra estación obtenido anteriormente.</td>
</tr>
<tr>
<td>SATNOGS_STATION_LAT</td>
<td>Latitud de nuestra estación.</td>
</tr>
<tr>
<td>SATNOGS_STATION_LON</td>
<td>Longitud de nuestra estación.</td>
</tr>
</tbody></table>
<img src="/2020/04/24/instalacion-satnogs/satnogs-setup_basic.png" class="" title="SatNOGS Setup">

<p>Volvemos al menú principal y vamos ahora a <strong><em>Advanced</em></strong> y <strong><em>Radio Settings</em></strong>. Aquí vamos a introducir los siguientes ajustes:</p>
<table>
<thead>
<tr>
<th>Ajuste</th>
<th>Descripción</th>
</tr>
</thead>
<tbody><tr>
<td>SATNOGS_PPM_ERROR</td>
<td>Valor de correción de frecuencia del dispositivo.</td>
</tr>
<tr>
<td>SATNOGS_RF_GAIN</td>
<td>Ganancia del dispositivo. Para el RTL-SDR introducimos cualquier valor de ganancia soportado: <code>0.0 0.9 1.4 2.7 3.7 7.7 8.7 12.5 14.4 15.7 16.6 19.7 20.7 22.9 25.4 28.0 29.7 32.8 33.8 36.4 37.2 38.6 40.2 42.1 43.4 43.9 44.5 48.0 49.6</code></td>
</tr>
</tbody></table>
<img src="/2020/04/24/instalacion-satnogs/satnogs-setup_advanced_radio.png" class="" title="SatNOGS Setup">

<p>Volvemos al menú principal y le damos a <strong><em>Apply</em></strong> para que se apliquen los ajustes. Cuando se termine de configurar podemos comprobar si se ha iniciado correctamente con:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status satnogs-client</span><br></pre></td></tr></table></figure>

<p>Si todo ha ido bien tendremos la siguiente salida:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">● satnogs-client.service - SatNOGS client</span><br><span class="line">   Loaded: loaded (&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;satnogs-client.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Fri 2020-04-23 19:33:57 UTC; 26min ago</span><br><span class="line"> Main PID: 27871 (satnogs-client)</span><br><span class="line">    Tasks: 22 (limit: 2200)</span><br><span class="line">   Memory: 55.7M</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;satnogs-client.service</span><br><span class="line">           └─27871 &#x2F;var&#x2F;lib&#x2F;satnogs&#x2F;bin&#x2F;python3 &#x2F;var&#x2F;lib&#x2F;satnogs&#x2F;bin&#x2F;satnogs-client</span><br></pre></td></tr></table></figure>

<h2 id="Programar-seguimientos-en-SatNOGS"><a href="#Programar-seguimientos-en-SatNOGS" class="headerlink" title="Programar seguimientos en SatNOGS"></a>Programar seguimientos en SatNOGS</h2><p>Con nuestra Raspberry Pi finalmente configurada, es el momento de comprobar que todo funciona correctamente y podemos realizar el seguimiento de satélites.</p>
<p>Para programar un pase debemos hacerlo desde el panel de control de SatNOGS. Nuestra Raspberry Pi se comunicará con la red de SatNOGS, realizará los seguimientos que le indiquemos y subirá los datos a la misma.</p>
<p>Tenemos dos formas de programar un seguimiento. La primera de ellas es calculando todos los pases de todos los satélites que pasarán por nuestra estación en las siguientes horas. Para ello vamos a nuestro panel de control, hacemos click en nuestra estación y le damos a <strong><em>Calculate Future Passes</em></strong>.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs_nuevo_pase.png" class="" title="SatNOGS Nuevo pase">

<p>Aparecen ahora los siguientes pases. Seleccionamos el deseado haciendo click en <strong><em>schedule</em></strong>.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs_nuevo_pase_2.png" class="" title="SatNOGS Nuevo pase">

<p>Comprobamos los datos de la observación y hacemos click en <strong><em>Schedule</em></strong>.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs_nuevo_pase_3.png" class="" title="SatNOGS Nuevo pase">

<p>La segunda forma de programar un pase es desde el panel del control. Aquí hacemos click en <strong><em>New Observation</em></strong>.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs_nuevo_pase_sat.png" class="" title="SatNOGS Nuevo pase">

<p>Seleccionamos el satélite que queremos seguir e indicamos un intervalos de tiempo. Después hacemos click en <strong><em>Calculate</em></strong> para calcular los pases. Por último seleccionamos el pase que nos interese y hacemos click en <strong><em>Schedule</em></strong>.</p>
<img src="/2020/04/24/instalacion-satnogs/satnogs_nuevo_pase_sat_2.png" class="" title="SatNOGS Nuevo pase">

<p>Cuando se completen los pases que hemos programado, podemos ver el <em>“waterfall”</em> del pase, el audio y los datos o imágenes obtenidas.</p>
<h2 id="Utilizacion-de-LNA"><a href="#Utilizacion-de-LNA" class="headerlink" title="Utilización de LNA"></a>Utilización de LNA</h2><p>Incorporar un LNA a nuestra estación nos ayudará a mejorar la recepción de los satélites. Si disponemos de un LNA con alimentación mediante Bias-T y utilizamos un dispositivo SDR como el RTL-SDR V3, tendremos que activar la alimentación del mismo.</p>
<p>A continuación veremos como hacer que SatNOGS active de forma automática el Bias-T de nuestro RTL-SDR cuando vaya a recibir un pase y lo desactive al finalizar.</p>
<p>Necesitamos instalar la utilidad <code>rtl_biast</code> que será la encargada de activar y desactivar el Bias-T del dispositivo SDR. Para ello accedemos por SSH a la Raspberry Pi y realizamos los siguientes pasos:</p>
<ol>
<li>Descargar el código fuente.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;rtlsdrblog&#x2F;rtl_biast.git</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Instalar las dependencias necesarias para compilar.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install cmake libusb-1.0-0-dev</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Accedemos a la carpeta descargada.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd rtl_biast</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Generamos el <em>makefile</em>.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Compilamos.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>Copiamos el binario compilado a <code>/usr/bin</code>.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp src&#x2F;rtl_biast &#x2F;usr&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>Por último, nos aseguramos de que funciona correctamente ejecutando:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtl_biast</span><br></pre></td></tr></table></figure>

<p>Debemos obtener una salida como la siguiente:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Found 1 device(s):</span><br><span class="line">  0:  Realtek, RTL2838UHIDIR, SN: 08201703</span><br><span class="line"></span><br><span class="line">Using device 0: Generic RTL2832U OEM</span><br><span class="line">Found Rafael Micro R820T tuner</span><br></pre></td></tr></table></figure>

<p>Ahora vamos a configurar el cliente SatNOGS para que active y desactive el Bias-T de forma automática.</p>
<p>Accedemos al menú de configuración mediante:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo satnogs-setup</span><br></pre></td></tr></table></figure>

<p>Vamos a <strong><em>Advanced</em></strong> y <strong><em>Pre/post observation scripts</em></strong> y establecemos los siguientes ajustes:</p>
<table>
<thead>
<tr>
<th>Ajuste</th>
<th>Valor</th>
</tr>
</thead>
<tbody><tr>
<td>SATNOGS_PRE_OBSERVATION_SCRIPT</td>
<td><code>/usr/bin/rtl_biast -b 1</code></td>
</tr>
<tr>
<td>SATNOGS_POST_OBSERVATION_SCRIPT</td>
<td><code>/usr/bin/rtl_biast -b 0</code></td>
</tr>
</tbody></table>
<p>Para finalizar volvemos al menú principal y le damos a <strong><em>Apply</em></strong> para que se apliquen los ajustes.</p>
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>RTL-SDR</tag>
        <tag>Raspberry Pi</tag>
        <tag>SatNOGS</tag>
      </tags>
  </entry>
  <entry>
    <title>Instalación de SPY Server en Raspberry Pi</title>
    <url>/2020/04/11/instalacion-spyserver-raspberrypi/</url>
    <content><![CDATA[<p>SPY Server es un software que permite crear un servidor SDR al que nos podemos conectar de forma remota mediante SDR#. Este software es desarrollado por Airspy siendo compatible con sus dispositivos pero también con los RTL-SDR.<br>En este artículo veremos como instalar SPY Server en una Raspberry Pi.</p>
<a id="more"></a>

<p>Para usar SPY Server en nuestra Raspberry Pi <strong>necesitamos en primer lugar tener instalado el dispositivo SDR</strong>. Si nuestro dispositivo es un RTL-SDR debemos seguir los pasos descritos en el artículo <a href="https://sdr-es.com/2020/04/10/instalacion-rtlsdr-raspberrypi/">“Instalación de dispositivos RTL-SDR en Raspberry Pi”</a>.</p>
<h2 id="Instalar-SPY-Server"><a href="#Instalar-SPY-Server" class="headerlink" title="Instalar SPY Server"></a>Instalar SPY Server</h2><p>SPY Server está disponible ya compilado para procesadores ARM de 32 bits, por lo que bastaría con descargarlo a nuestra Raspberry Pi para que funcione.</p>
<p>Lo primero que haremos será crear un directorio nuevo para los archivos de SPY Server:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir SPY_Server &amp;&amp; cd $_</span><br></pre></td></tr></table></figure>

<p>Descargamos SPY Server usando el siguiente comando:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;airspy.com&#x2F;downloads&#x2F;spyserver-arm32.tgz</span><br></pre></td></tr></table></figure>

<p>Extraemos el contenido:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xzf spyserver-arm32.tgz</span><br></pre></td></tr></table></figure>

<p>SPY Server funciona correctamente con los valores por defecto. También detecta el dispositivo SDR de forma automática y selecciona el primero disponible. Si necesitamos realizar algún ajuste debemos editar el archivo <strong>spyserver.config</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nano spyserver.config</span><br></pre></td></tr></table></figure>

<p>Por último ejecutamos SPY Server:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;spyserver spyserver.config</span><br></pre></td></tr></table></figure>

<p>Si todo ha ido bien, nos mostrará una salida como la siguiente:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SPY Server v2.0.1700</span><br><span class="line">Copyright (C) 2016-2018 Youssef Touil - https:&#x2F;&#x2F;airspy.com</span><br><span class="line">Reading the configuration file: spyserver.config</span><br><span class="line">Listening for connections on 0.0.0.0:5555</span><br></pre></td></tr></table></figure>


<p>Necesitamos que SPY Server funcione de forma autónoma en la Raspberry Pi y que se inicie de forma automática cuando esta se reinicie. Para ello vamos a lanzar SPY Server como un servicio.</p>
<p>Lo primero será crear un archivo <em>unit</em> con la información del servicio:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;spyserver.service</span><br></pre></td></tr></table></figure>

<p>El contenido del archivo será el siguiente (modificar las rutas si es necesario):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;SPY Server</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">StartLimitIntervalSec&#x3D;0</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">Restart&#x3D;always</span><br><span class="line">RestartSec&#x3D;1</span><br><span class="line">User&#x3D;pi</span><br><span class="line">WorkingDirectory&#x3D;&#x2F;home&#x2F;pi&#x2F;SPY_Server</span><br><span class="line">ExecStart&#x3D;&#x2F;home&#x2F;pi&#x2F;SPY_Server&#x2F;spyserver spyserver.config</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>

<p>Ahora vamos a cargar el servicio en el arranque mediante el siguiente comando:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable spyserver</span><br></pre></td></tr></table></figure>

<p>Por último iniciamos el servicio:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start spyserver</span><br></pre></td></tr></table></figure>

<p>Para consultar el estado del servicio ejecutamos:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl status spyserver</span><br></pre></td></tr></table></figure>

<p>Si todo está correcto tendremos la siguiente salida:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">● spyserver.service - SPY Server</span><br><span class="line">   Loaded: loaded (&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;spyserver.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Fri 2020-04-10 21:45:26 CEST; 13s ago</span><br><span class="line"> Main PID: 20788 (spyserver)</span><br><span class="line">    Tasks: 2 (limit: 2200)</span><br><span class="line">   Memory: 252.0K</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;spyserver.service</span><br><span class="line">           └─20788 &#x2F;home&#x2F;pi&#x2F;SPY_Server&#x2F;spyserver</span><br><span class="line"></span><br><span class="line">Apr 10 21:45:26 raspberrypi systemd[1]: Started SPY Server.</span><br></pre></td></tr></table></figure>

<h2 id="Conectar-SDR-a-SPY-Server"><a href="#Conectar-SDR-a-SPY-Server" class="headerlink" title="Conectar SDR# a SPY Server"></a>Conectar SDR# a SPY Server</h2><p>El último paso será conectarnos a nuestro servidor desde SDR#. Para ello seleccionamos <strong>SPY Server Network</strong> en el desplegable de seleción de fuentes e introducimos la dirección IP del servidor de la siguiente forma:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdr:&#x2F;&#x2F;IP_RASPBERRY:5555</span><br></pre></td></tr></table></figure>
<br>
<img src="/2020/04/11/instalacion-spyserver-raspberrypi/conectar.png" class="" title="Conexión">

<p>Por último hacemos click en la <strong>C</strong> para conectarnos.</p>
<img src="/2020/04/11/instalacion-spyserver-raspberrypi/sdr_sharp.png" class="" width="900" title="SDR#">
]]></content>
      <tags>
        <tag>SDRSharp</tag>
        <tag>RTL-SDR</tag>
        <tag>Raspberry Pi</tag>
        <tag>Linux</tag>
        <tag>SPY Server</tag>
      </tags>
  </entry>
  <entry>
    <title>Instalación de cable de audio virtual</title>
    <url>/2020/01/21/instalacion-virtual-cable-audio/</url>
    <content><![CDATA[<p>Vamos a ver como instalar un cable virtual para poder pasar la señal de audio desde un programa que demodule señales a cualquier programa externo. Este cable virtual es simplemente un programa que conecta la salida de audio de un programa con la entrada de otro mediante software.</p>
<a id="more"></a>

<h2 id="Instalacion-de-VB-Cable-en-Windows"><a href="#Instalacion-de-VB-Cable-en-Windows" class="headerlink" title="Instalación de VB-Cable en Windows"></a>Instalación de VB-Cable en Windows</h2><p>Existen distintos programas que realizan esta operación, pero en este tutorial usaremos la alternativa gratuita (Donationware) <strong>VB-Cable</strong>.</p>
<p>Descargamos el instalador desde la web de VB-Audio desde el siguiente enlace:</p>
<p><a href="https://www.vb-audio.com/Cable/" target="_blank" rel="noopener"><center>https://www.vb-audio.com/Cable/</center></a></p>
<img src="/2020/01/21/instalacion-virtual-cable-audio/virtual-cable-descarga-windows.jpg" class="" width="900" title="Descarga de VB-Cable">

<p>Hacemos click en <strong><em>Download</em></strong> y una vez descargado extraemos el contenido del archivo ZIP.</p>
<p>Buscamos ahora el ejecutable <strong>VBCABLE_Setup_x64.exe</strong> o <strong>VBCABLE_Setup.exe</strong>, dependiendo de la arquitectura de nuestro PC, y lo ejecutamos como Administrador.</p>
<img src="/2020/01/21/instalacion-virtual-cable-audio/virtual-cable-instalacion.jpg" class="" title="Instalando VB-Cable">

<p>Hacemos click en <strong>Install Driver</strong> y esperamos a que se complete la instalación. Es posible que nos pida confirmar la instalación de los drivers para poder continuar.<br>Si todo ha ido bien, nos aparecerá un mensaje indicando que se han instalado los drivers correctamente y que debemos reiniciar. Así que reiniciamos nuestro PC y ya tendremos instalado el cable virtual.</p>
<h3 id="Configuracion-de-SDR"><a href="#Configuracion-de-SDR" class="headerlink" title="Configuración de SDR#"></a>Configuración de SDR#</h3><p>Abrimos ahora SDR# y desplegamos la pestaña para la configuración de Audio. Para indicarle a SDR# que saque el audio por el cable virtual, debemos hacer click en <strong>Output</strong> y seleccionar <strong>[MME] CABLE Input …</strong>.</p>
<img src="/2020/01/21/instalacion-virtual-cable-audio/sdrsharp-audio.jpg" class="" width="800" title="SDRSharp output">

<p>Ahora cuando iniciemos SDR# el audio saldrá por el cable de audio virtual y para recibirlo en otro programa bastaría con seleccionar el cable virtual como entrada.</p>
<h2 id="Instalacion-de-VB-Cable-en-macOS"><a href="#Instalacion-de-VB-Cable-en-macOS" class="headerlink" title="Instalación de VB-Cable en macOS"></a>Instalación de VB-Cable en macOS</h2><p>Descargamos el instalador desde la web de VB-Audio desde el siguiente enlace:</p>
<p><a href="https://www.vb-audio.com/Cable/" target="_blank" rel="noopener"><center>https://www.vb-audio.com/Cable/</center></a></p>
<img src="/2020/01/21/instalacion-virtual-cable-audio/virtual-cable-descarga-macos.jpg" class="" width="900" title="Descarga de VB-Cable">

<p>Hacemos click en <strong><em>Download</em></strong> y una vez descargado ejecutamos el instalador.</p>
<img src="/2020/01/21/instalacion-virtual-cable-audio/virtual-cable-instalacion-macos1.jpg" class="" title="Instalación de VB-Cable">

<p>Seguimos los pasos del asistente para instalar VB-Audio.</p>
<img src="/2020/01/21/instalacion-virtual-cable-audio/virtual-cable-instalacion-macos2.jpg" class="" title="Instalación de VB-Cable">

<h3 id="Configuracion-de-CubicSDR"><a href="#Configuracion-de-CubicSDR" class="headerlink" title="Configuración de CubicSDR"></a>Configuración de CubicSDR</h3><p>Debemos indicarle a CubicSDR que nos saque el audio utilizando el cable de audio virtual. Para ello hacemos click en <strong>Audio Out</strong> y seleccionamos <em><strong>VB Audio: VB-Cable</strong></em></p>
<img src="/2020/01/21/instalacion-virtual-cable-audio/cubicsdr-audio.jpg" class="" width="900" title="CubicSDR audio output">

<p>Ahora el audio saldrá por el cable de audio virtual y para recibirlo en otro programa bastaría con seleccionar el cable virtual como entrada.</p>
]]></content>
      <tags>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
        <tag>macOS</tag>
        <tag>CubicSDR</tag>
        <tag>Virtual Audio Cable</tag>
      </tags>
  </entry>
  <entry>
    <title>Recepción de los satélites CAS-4</title>
    <url>/2020/10/10/recepcion-cas4/</url>
    <content><![CDATA[<p>Los satélites CAS-4A y CAS-4B son unos micro-satélites construidos por Zhuhai Orbita Control Engineering Ltd. para el sistema orbital de observación terrestre de China. Su principal componente es una cámara de 1,98m de resolución. Estos satélites envían datos de telemetría en VHF, y son estos datos los que vamos a recibir, decodificar y visualizar en este artículo.</p>
<a id="more"></a>

<h2 id="Datos-de-los-satelites"><a href="#Datos-de-los-satelites" class="headerlink" title="Datos de los satélites"></a>Datos de los satélites</h2><table>
<thead>
<tr>
<th>Satélite</th>
<th>ZHUHAI-1 01 (CAS-4A)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Operador</strong></td>
<td>Zhuhai Orbita Control Engineering Co. Ltd.</td>
</tr>
<tr>
<td><strong>NORAD ID</strong></td>
<td>42761</td>
</tr>
<tr>
<td><strong>COSPAR ID</strong></td>
<td>2017-034D</td>
</tr>
<tr>
<td><strong>Tamaño</strong></td>
<td>Microsatélite 494Lx499Wx630H mm (55 Kg)</td>
</tr>
<tr>
<td><strong>Lanzamiento</strong></td>
<td>15 de Junio de 2017</td>
</tr>
<tr>
<td><strong>Señal</strong></td>
<td>Telemetría: 145,835 MHz (AX.25 4,8k Baud GMSK) <br> Baliza: 145,855 MHz (CW) <br> Transpondedor linear: 145,870 MHz (Bajada) - 435,220 MHz (Subida)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Satélite</th>
<th>ZHUHAI-1 02 (CAS-4B)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Operador</strong></td>
<td>Zhuhai Orbita Control Engineering Co. Ltd.</td>
</tr>
<tr>
<td><strong>NORAD ID</strong></td>
<td>42759</td>
</tr>
<tr>
<td><strong>COSPAR ID</strong></td>
<td>2017-034B</td>
</tr>
<tr>
<td><strong>Tamaño</strong></td>
<td>Microsatélite 494Lx499Wx630H mm (55 Kg)</td>
</tr>
<tr>
<td><strong>Lanzamiento</strong></td>
<td>15 de Junio de 2017</td>
</tr>
<tr>
<td><strong>Señal</strong></td>
<td>Telemetría: 145,890 MHz (AX.25 4,8k Baud GMSK) <br> Baliza: 145,910 MHz (CW) <br> Transpondedor linear: 145,925 MHz (Bajada) - 435,280 MHz (Subida)</td>
</tr>
</tbody></table>
<img src="/2020/10/10/recepcion-cas4/satelite.jpg" class="" width="600" title="Satélites CAS-4">


<h2 id="Recepcion"><a href="#Recepcion" class="headerlink" title="Recepción"></a>Recepción</h2><p>Los satélites envían los datos de telemetría en las frecuencias <strong>145.835 MHz</strong> (CAS-4A) y <strong>145.890 MHz</strong> (CAS-4B). Para recibir la señal debemos realizar los pasos habituales para el seguimiento de satélites que ya vimos en el artículo <a href="/2020/02/18/ajuste-frecuencia-doppler-orbitron/">“Ajuste de frecuencia en recepción de satélites”</a>.</p>
<p>Los datos para DDETracker son los siguientes:</p>
<p><strong>AOS:</strong><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">radio_Start</span><br><span class="line">radio_modulation_type&lt;nfm&gt;</span><br><span class="line">radio_bandwidth_Hz&lt;10000&gt;</span><br><span class="line">radio_tracking_frequency_On</span><br></pre></td></tr></table></figure></p>
<h2 id="Decodificar-la-senal"><a href="#Decodificar-la-senal" class="headerlink" title="Decodificar la señal"></a>Decodificar la señal</h2><p>Estos satélites utilizan el protocolo AX.25 en modo KISS. Para decodificar este modo necesitamos instalar el software <a href="http://uz7.ho.ua/packetradio.htm" target="_blank" rel="noopener">Packet-Radio TNC</a> que utiliza la tarjeta de sonido de nuestro ordenador como un modem para AX.25.<br>Podemos descargar el programa desde el siguiente enlace:<br><a href="http://uz7.ho.ua/modem_beta/hs_soundmodem21.zip" target="_blank" rel="noopener"><center>Descargar High-Speed SoundModem by UZ7HO</center></a></p>
<p>Una vez descargado el archivo, extraemos el contenido en el directorio que queramos. Posteriormente ejecutamos el archivo <strong><em>hs_soundmodem.exe</em></strong> y se nos abrirá la interfaz del programa.</p>
<p>El siguiente paso es configurar el programa para que reciba el audio desde SDR#. Para ello hacemos clic en <em>Settings</em> y en <strong>Input device</strong> seleccionamos el <a href="/2020/01/21/instalacion-virtual-cable-audio/">cable de audio virtual</a>. También debemos activar el <strong>KISS Server Port</strong>.</p>
<img src="/2020/10/10/recepcion-cas4/HS_SoundModem_settings.png" class="" width="400" title="Ajustes de HS SoundModem">

<p>Por último, seleccionamos el modo <strong>FSK G3RUH 4800bd</strong> en la ventana principal del programa.</p>
<img src="/2020/10/10/recepcion-cas4/HS_SoundModem.png" class="" width="370" title="HS SoundModem">


<h2 id="Procesar-los-datos"><a href="#Procesar-los-datos" class="headerlink" title="Procesar los datos"></a>Procesar los datos</h2><p>Una vez tenemos la parte que decodifica la señal, necesitamos configurar la parte que se va a encargar de procesar los datos en modo KISS decodificados y generar un archivo con todos los mensajes para su posterior visualización. Para ello vamos a usar el software <strong>GetKISS</strong> de <a href="https://www.dk3wn.info/wp/ueber-mich/" target="_blank" rel="noopener">DK3WN</a>, que podemos descargar desde el siguiente enlace:<br><a href="https://www.dk3wn.info/files/getkiss.zip" target="_blank" rel="noopener"><center>Descargar GetKISS</center></a></p>
<p>Una vez descargado y extraído el contenido, tenemos que editar algunos ajustes en el archivo <strong><em>conf.ini</em></strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># This is the ini file for GetKISS</span><br><span class="line">#</span><br><span class="line"># use tcp port 52002 for ubuntu decoder and port 8100 for windows soundmodem</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">FILE_PATH &#x3D; D:\Amateurfunk &lt;-- Carpeta en la que se guardarán los datos</span><br><span class="line">#</span><br><span class="line">CALLSIGN &#x3D; DK3WN</span><br><span class="line">#</span><br><span class="line"># use QTH height in km</span><br><span class="line">#</span><br><span class="line">QTH_LAT &#x3D; 49.7 &lt;-- Latitud</span><br><span class="line">QTH_LONG &#x3D; 8.95  &lt;-- Longitud</span><br><span class="line">QTH_HEIGHT &#x3D; 0.2 &lt;-- Altitud en kilómetros</span><br><span class="line">#</span><br><span class="line">TLEFILE &#x3D; D:\Amateurfunk\Orbitron\TLE\amateur.txt &lt;-- Archivo TLE que contenga los satélites CAS-4</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">#TCP_SERVER &#x3D; 192.168.178.28</span><br><span class="line">#TCP_PORT &#x3D; 52002</span><br><span class="line"></span><br><span class="line">TCP_SERVER &#x3D; localhost</span><br><span class="line">TCP_PORT &#x3D; 8100</span><br></pre></td></tr></table></figure>

<p>Una vez modificado el archivo, iniciamos el programa haciendo clic en <strong>getkiss.exe</strong>. Es posible que nos de algún error al iniciar si no tenemos instalados ciertos componentes Active-X. Para solucionarlo debemos descargar el siguiente archivo que contiene los archivos OCX que suelen faltar:<br><a href="https://www.dk3wn.info/files/ocx.zip" target="_blank" rel="noopener"><center>Descargar archivos OCX</center></a></p>
<p>Una vez descargado, extraemos el archivo OCX que falte dentro de la carpeta en la que hemos guardado GetKISS en el paso anterior. Después registramos el archivo OCX en el sistema ejecutando el siguiente comando en una consola del sistema (como Administrador):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">regsvr32 RUTA_COMPLETA_DEL_ARCHIVO.OCX</span><br></pre></td></tr></table></figure>

<img src="/2020/10/10/recepcion-cas4/regsvr32.png" class="" width="800" title="regsvr32">

<p>Si todo ha ido bien, al ejecutar el programa GetKISS nos debe aparecer una ventana como la siguiente:</p>
<img src="/2020/10/10/recepcion-cas4/GetKISS.png" class="" width="600" title="GetKISS">

<p>Ahora debemos seleccionar el satélite que vamos a recibir (CAS-4A o CAS-4B). Si el satélite seleccionado está sobre el horizonte, nos aparecerá debajo la posición de este en color verde.</p>
<p>Por último, marcamos la casilla <strong>TCP client</strong>. Si tenemos el programa <strong>HS SounModem</strong> iniciado y correctamente configurado, debe conectarse y mostrar el indicador de color verde.</p>
<h2 id="Recibiendo-el-pase"><a href="#Recibiendo-el-pase" class="headerlink" title="Recibiendo el pase"></a>Recibiendo el pase</h2><p>Si tenemos todos los pasos anteriores correctamente configurados, toca ahora esperar a que pasen los satélites y comenzar a recibir mensajes.</p>
<img src="/2020/10/10/recepcion-cas4/CAS-4B.png" class="" width="800" title="CAS-4B">
<br/>
<img src="/2020/10/10/recepcion-cas4/CAS-4A.png" class="" width="800" title="CAS-4A">


<h2 id="Decodificando-la-telemetria"><a href="#Decodificando-la-telemetria" class="headerlink" title="Decodificando la telemetría"></a>Decodificando la telemetría</h2><p>Una vez hemos recibido el pase de uno de de estos satélites, y si todo ha ido bien, tendremos un archivo generado con los datos dentro la carpeta que le indicamos a GetKISS en el archivo de configuración. Para visualizar estos datos vamos a usar el programa <strong>CAS-4 Telemetry Beacon Decoder</strong> de <a href="https://www.dk3wn.info/wp/ueber-mich/" target="_blank" rel="noopener">DK3WN</a>, que podemos descargar desde el siguiente enlace:<br><a href="https://www.dk3wn.info/files/cas4ab.zip" target="_blank" rel="noopener"><center>Descargar CAS-4AB digital telemetry decoder v.0.2</center></a></p>
<p>Una vez descargado, extraemos el contenido y ejecutamos el programa. Puede que nos de problemas con los archivos OCX, pero podemos solucionarlos siguiendo los pasos descritos anteriormente.</p>
<p>Una vez abierto, vamos a <strong>File</strong>, <strong>Open Kissfile</strong> y seleccionamos el archivo <em>.kss</em> que queramos visualizar.</p>
<img src="/2020/10/10/recepcion-cas4/decoder.png" class="" width="500" title="CAS-4 Telemetry Decoder">


<h2 id="Agradecimientos"><a href="#Agradecimientos" class="headerlink" title="Agradecimientos"></a>Agradecimientos</h2><p>Gracias a <a href="http://uz7.ho.ua/" target="_blank" rel="noopener">Andrei (UZ7HO)</a> y a <a href="https://www.dk3wn.info/wp/ueber-mich/" target="_blank" rel="noopener">Mike Rupprecht (DK3WN)</a> por crear y compartir algunos de los programas usados en este artículo.<br>Si te han parecido útiles y quieres agradecer su trabajo, puedes realizarles un donativo desde su web.</p>
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Recepción de datos del instrumental HIRS de los satélites NOAA</title>
    <url>/2020/07/27/recepcion-datos-HIRS-satelites-NOAA/</url>
    <content><![CDATA[<p>Como vimos en el artículo <a href="/2020/03/20/recepcion-satelites-meteorologicos-NOAA/">“Recepción de satélites meteorológicos NOAA”</a>, es posible recibir las imágenes desde estos satélites meteorológicos con nuestro dispositivo SDR. Estos satélites envían, además de imágenes, datos de medidas de su instrumental de observación HIRS y que también podemos recibir.</p>
<p>El HIRS <em>(High Resolution Infrared Radiation Sounder)</em> es un instrumental de escaneo incremental por líneas diseñado para medir la radiación en 20 bandas espectrales. Esta medición permite calcular el perfil de temperatura vertical de la superficie de la Tierra a una altura aproximada de 40 kilómetros.<br>Los datos multiespectrales del canal visible (0,69 µm), de los siete canales de onda corta (3,7 a 4,6 µm) y de los doce canales de onda larga (6,5 a 15 µm) se obtienen desde el mismo telescopio utilizando una lente rotativa con veinte filtros individuales.</p>
<a id="more"></a>

<h2 id="Datos-de-los-satelites"><a href="#Datos-de-los-satelites" class="headerlink" title="Datos de los satélites"></a>Datos de los satélites</h2><p>Los satélites activos de los que podemos recibir la señal son los siguientes:</p>
<table>
<thead>
<tr>
<th>Satélite</th>
<th>Frecuencia</th>
<th>Estado</th>
</tr>
</thead>
<tbody><tr>
<td>NOAA 15</td>
<td>137.350 Mhz</td>
<td><a href="https://www.ospo.noaa.gov/Operations/POES/NOAA15/hirs.html" target="_blank" rel="noopener">Consultar</a></td>
</tr>
<tr>
<td>NOAA 18</td>
<td>137.350 Mhz</td>
<td><a href="https://www.ospo.noaa.gov/Operations/POES/NOAA18/hirs.html" target="_blank" rel="noopener">Consultar</a></td>
</tr>
<tr>
<td>NOAA 19</td>
<td>137.770 Mhz</td>
<td><a href="https://www.ospo.noaa.gov/Operations/POES/NOAA19/hirs.html" target="_blank" rel="noopener">Consultar</a></td>
</tr>
</tbody></table>
<h2 id="Recepcion"><a href="#Recepcion" class="headerlink" title="Recepción"></a>Recepción</h2><p>En este ejemplo vamos a ver como recibir estos datos desde Windows, aunque también es posible hacerlo desde cualquier sistema operativo.</p>
<p>El proceso de recepción es similar al de recibir las imágenes, solo que en este caso grabaremos la señal para su posterior demodulación y decodificación.</p>
<p>Lo primero que haremos será configurar Orbitron u otro programa para que nos realice la corrección de la frecuencia durante el pase.</p>
<p>Posteriormente ajustamos el <strong>ancho de banda a 32 KHz</strong> en SDR# y <strong>modo RAW</strong>.</p>
<p>Ahora esperamos a que pase el satélite y cuando tengamos señal comenzamos la grabación de la misma (<strong>solo audio</strong>, el baseband lo desmarcamos). Cuando termine el pase y perdamos la señal detenemos la grabación.</p>
<img src="/2020/07/27/recepcion-datos-HIRS-satelites-NOAA/grabacion.jpg" class="" width="900" title="SDR#">


<h2 id="Demodular-la-senal"><a href="#Demodular-la-senal" class="headerlink" title="Demodular la señal"></a>Demodular la señal</h2><p>El siguiente paso es demodular la señal obtenida en el paso anterior. Para ello vamos a utilizar el demodulador <em>Project Desert Tortoise</em> que podemos descargar desde el siguiente enlace:</p>
<p><a href="https://github.com/nebarnix/Project-Desert-Tortoise/archive/master.zip" target="_blank" rel="noopener"><center>Project Desert Tortoise - Demodulator</center></a></p>
<p>Una vez descargado, extraemos el contenido del archivo.</p>
<p>Ahora buscamos el archivo de audio del paso anterior (SDR# debe haberlo generado en su carpeta de instalación) y lo copiamos a la carpeta de <em>Project Desert Tortoise</em> que acabamos de extraer.</p>
<img src="/2020/07/27/recepcion-datos-HIRS-satelites-NOAA/demodulador.jpg" class="" title="Project Desert Tortoise">

<p>Para demodular el archivo basta con hacer click encima del archivo de audio y arrastrarlo encima del binario <strong>demodPOES.exe</strong> y soltar. Esto hace que se pase el archivo de audio como parámetro al binario. También podemos hacerlo mediante la línea de comando si queremos.</p>
<p>Cuando el demodulador procese el archivo de audio completo, generará un nuevo archivo con los datos en ese mismo directorio con el nombre <em><strong>minorFrames_xxxx.txt</strong></em>.</p>
<p>Más información sobre el demodulador: <a href="http://wiki.nebarnix.com/wiki/NOAA_POES_TIP_Demodulation" target="_blank" rel="noopener">http://wiki.nebarnix.com/wiki/NOAA_POES_TIP_Demodulation</a></p>
<h2 id="Decodificacion"><a href="#Decodificacion" class="headerlink" title="Decodificación"></a>Decodificación</h2><p>El último paso es decodificar los datos obtenidos en el paso anterior. Para ello utilizamos el software <em>NOAA HIRS Decoder</em> que podemos descargar desde la web:</p>
<p><a href="https://noaa_hirs_decoder.surge.sh/download.html" target="_blank" rel="noopener"><center>NOAA HIRS Decoder</center></a></p>
<p>Necesitamos tener instalada la máquina virtual de Java para poder ejecutar el software. Podemos descargar la ultima versión desde la <a href="https://www.java.com/es/download/" target="_blank" rel="noopener">web oficial de Oracle</a>.</p>
<p>Una vez descargado el <em>NOAA HIRS Decoder</em>, extraemos el contenido en un directorio y copiamos el archivo del paso anterior dentro del mismo.</p>
<p>Ahora le pasamos el archivo <em><strong>minorFrames_xxxx.txt</strong></em> como parámetro al binario <strong>NOAA_HIRS_Decoder.exe</strong> de la misma forma que vimos en el paso anterior (arrastrar y soltar).</p>
<p>Una vez termine el proceso de decodificación veremos los datos dentro del directorio <em>output/minorFrames_xxxx</em>.</p>
<img src="/2020/07/27/recepcion-datos-HIRS-satelites-NOAA/decoder.jpg" class="" title="NOAA HIRS Decoder">

<p>Tendremos una serie de imágenes por cada uno de los canales. Estas imágenes son de 56 píxeles de ancho y el largo depende de la duración de la grabación.</p>
<img src="/2020/07/27/recepcion-datos-HIRS-satelites-NOAA/Compo.png" class="" title="NOAA HIRS Decoder">
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
        <tag>Satélites meteorológicos</tag>
      </tags>
  </entry>
  <entry>
    <title>Recepción de mensajes Inmarsat Aero</title>
    <url>/2020/03/10/recepcion-aero-inmarsat/</url>
    <content><![CDATA[<p>Como ya hemos visto en artículos anteriores, es posible recibir y decodificar algunas señales desde los satélites Inmarsat.<br>En este artículo veremos como decodificar y recibir mensajes Aero.</p>
<p>Inmarsat Aero es el protocolo utilizado para las comunicaciones entre las estaciones de control terrestres y las aeronaves en vuelo mediante satélite. Usando este protocolo se transmiten mensajes <a href="https://es.wikipedia.org/wiki/ACARS" target="_blank" rel="noopener">ACARS</a>, ADS-C, fax y voz digital.</p>
<a id="more"></a>

<p>Para decodificar este protocolo utilizaremos el software Open Source <strong>JAERO</strong>. Podemos descargarlo desde el siguiente enlace:</p>
<p><a href="https://github.com/jontio/JAERO/releases/download/v1.0.4.11/JAERO-x64-setup.exe" target="_blank" rel="noopener"><center>JAERO x64 v1.0.4.11</center></a></p>
<p>Una vez descargado e instalado, procedemos a configurar algunos ajustes. Para ello iniciamos el programa y hacemos click en <em>Tools</em> y en <em>Settings</em>. Esto abre la ventana de ajustes de JAERO.</p>
<img src="/2020/03/10/recepcion-aero-inmarsat/jaero_config.jpg" class="" title="Configuración JAERO">

<p>El primer ajuste es indicarle en el apartado de <em>Soundcard</em> que le vamos a pasar el audio desde SDR# por el cable de audio virtual.<br>El siguiente ajuste es indicarle la ubicación de la base de datos con los datos de las aeronaves. Para ello en el apartado <em>Database</em> nos aseguramos de que la ruta es correcta y le damos a <strong>Download</strong> para que se descargue una base de datos actualizada. Si todo ha ido bien, deberíamos tener un archivo CSV con los datos en la ruta indicada.</p>
<p>Para recibir datos bastaría con sintonizar SDR# en la frecuencia requerida y ajustar JAERO para que decodifique los mensajes.</p>
<p>Inmarsat emite la señal en diferentes modulaciones y frecuencias. A continuación veremos ejemplos cada una.</p>
<h2 id="Aero-600-bps"><a href="#Aero-600-bps" class="headerlink" title="Aero 600 bps"></a>Aero 600 bps</h2><ul>
<li><strong>Modulación:</strong> Aviation-BPSK.</li>
<li><strong>Ancho de banda:</strong> 800 Hz.</li>
<li><strong>Frecuencia:</strong> 1545,10 - 1545,25 MHz (IOR).</li>
</ul>
<img src="/2020/03/10/recepcion-aero-inmarsat/acars_600_sdr.jpg" class="" title="AERO 600 bps">
</br>
<img src="/2020/03/10/recepcion-aero-inmarsat/acars_600_jaero.jpg" class="" title="AERO 600 bps">
</br>
<img src="/2020/03/10/recepcion-aero-inmarsat/acars_600_planelog.jpg" class="" title="AERO 600 bps planelog">


<h2 id="Aero-1200-bps"><a href="#Aero-1200-bps" class="headerlink" title="Aero 1200 bps"></a>Aero 1200 bps</h2><ul>
<li><strong>Modulación:</strong> Aviation-BPSK.</li>
<li><strong>Ancho de banda:</strong> 1600 Hz.</li>
<li><strong>Frecuencia:</strong> 1545,10 - 1545,25 MHz (IOR).</li>
</ul>
<img src="/2020/03/10/recepcion-aero-inmarsat/acars_1200_sdr.jpg" class="" title="AERO 1200 bps">
</br>
<img src="/2020/03/10/recepcion-aero-inmarsat/acars_1200_jaero.jpg" class="" title="AERO 1200 bps">


<h2 id="Aero-H-Aero-H"><a href="#Aero-H-Aero-H" class="headerlink" title="Aero-H, Aero-H+"></a>Aero-H, Aero-H+</h2><ul>
<li><strong>Modulación:</strong> Aviation-QPSK</li>
<li><strong>Ancho de banda:</strong> 10,5 KHz</li>
<li><strong>Frecuencia:</strong> 1546,0 - 1546,2 MHz (IOR).</li>
</ul>
<img src="/2020/03/10/recepcion-aero-inmarsat/aero_sdr.jpg" class="" title="AERO 10.5k">
</br>
<img src="/2020/03/10/recepcion-aero-inmarsat/aero_jaero.jpg" class="" title="AERO 10.5k">
</br>
<img src="/2020/03/10/recepcion-aero-inmarsat/aero_planelog.jpg" class="" title="AERO 10.5k planelog">


<h2 id="Voz-Digital"><a href="#Voz-Digital" class="headerlink" title="Voz Digital"></a>Voz Digital</h2><ul>
<li><strong>Modulación:</strong> Aviation-QPSK.</li>
<li><strong>Ancho de banda:</strong> 6 KHz.</li>
<li><strong>Frecuencia:</strong> 1546,13 - 1546,18 MHz (IOR).</li>
</ul>
<img src="/2020/03/10/recepcion-aero-inmarsat/aero_call_sdr.jpg" class="" title="AERO 10.5k">
</br>
<img src="/2020/03/10/recepcion-aero-inmarsat/aero_call_jaero.jpg" class="" title="AERO 10.5k">
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
        <tag>Inmarsat</tag>
        <tag>L-Band</tag>
      </tags>
  </entry>
  <entry>
    <title>Recepción de satélites Inmarsat</title>
    <url>/2020/03/06/recepcion-inmarsat/</url>
    <content><![CDATA[<p>Inmarsat es un proveedor de comunicaciones vía satélite con sede en Reino Unido. La constelación de satélites Inmarsat se compone actualmente de 12 satélites geoestacionarios que proporcionan cobertura en el 90% del planeta.<br>Inmarsat utiliza sus satélites de tercera y cuarta generación para ofrecer servicios de comunicaciones utilizando la <strong>banda L</strong> (1 a 2 GHz). Estos servicios son:</p>
<ul>
<li><p><strong>AERO</strong>. Es la versión de ACARS a través de satélite. Son mensajes enviados desde los controles aéreos en tierra a los aviones en vuelo.</p>
</li>
<li><p><strong>SafetyNET (SDT-C)</strong>. Es un servicio de comunicaciones por satélite para embarcaciones. Ofrecen servicio de mensajería entre barcos, mensajes de alerta, partes meteorológicos, mensajes de rescate, etc.</p>
</li>
</ul>
<p>En este artículo nos centraremos en cómo poder recibir la señal y en los sucesivos artículos veremos como recibir datos de cada uno de estos servicios.</p>
<a id="more"></a>

<h2 id="Antenas"><a href="#Antenas" class="headerlink" title="Antenas"></a>Antenas</h2><p>Existen diferentes tipos de antenas que nos permiten recibir la señal de los satélites en la banda L. A continuación veremos algunos ejemplos de antenas que podemos utilizar.</p>
<h3 id="Antena-patch-PCB"><a href="#Antena-patch-PCB" class="headerlink" title="Antena patch PCB"></a>Antena patch PCB</h3><p>Nooelec comercializa una antena específica para Inmarsat y que podemos adquirir desde su tienda en Estados Unidos o desde España a través de Amazon. Para poder recibir la señal tendremos que acompañarla de un LNA.</p>
<table>
<thead>
<tr>
<th>Frecuencia</th>
<th>Ganancia</th>
<th>Especificaciones</th>
</tr>
</thead>
<tbody><tr>
<td>1546 - 1554 MHz</td>
<td>~3.5 dBi</td>
<td><a href="https://www.nooelec.com/store/downloads/dl/file/id/91/product/314/inmarsat_antenna_datasheet_revision_1.pdf" target="_blank" rel="noopener">Datasheet</a></td>
</tr>
</tbody></table>
<img src="/2020/03/06/recepcion-inmarsat/antenna_nooelec.jpg" class="" title="Antena Nooelec">


<h3 id="Antena-patch-air-gap"><a href="#Antena-patch-air-gap" class="headerlink" title="Antena patch air-gap"></a>Antena patch air-gap</h3><p>Esta antena se comercializaba para Outernet (ahora <a href="https://othernet.is/" target="_blank" rel="noopener">Othernet</a>) en 2016 y quedó descatalogada cuando cambiaron de satélite y de banda. Aunque ya no se comercializa, podemos encontrar algunas existencias en eBay. Con esta antena necesitaremos un LNA para recibir la señal del satélite.</p>
<table>
<thead>
<tr>
<th>Frecuencia</th>
<th>Ganancia</th>
<th>Especificaciones</th>
</tr>
</thead>
<tbody><tr>
<td>1525 - 1559 MHz</td>
<td>8 dBi</td>
<td><a href="https://othernet.is/products/l-band-patch-antenna" target="_blank" rel="noopener">Othernet</a></td>
</tr>
</tbody></table>
<img src="/2020/03/06/recepcion-inmarsat/antena_patch.jpg" class="" title="Antena Patch">

<p>También podemos optar por construir nuestra propia antena. Las medidas son las que se indican en la siguiente imagen.<br>Podemos encontrar más información sobre esta antena en <a href="https://www.semanticscholar.org/paper/Design-of-a-parabolic-patch-antenna-in-band-L%2C-with-DavidAguirre-Yanyachi/8eaf743c9569e60b1891e964026693766f2727a4" target="_blank" rel="noopener">este enlace</a>.</p>
<img src="/2020/03/06/recepcion-inmarsat/antena_patch_medidas.jpg" class="" title="Antena Patch medidas">


<h3 id="Antena-patch-activa"><a href="#Antena-patch-activa" class="headerlink" title="Antena patch activa"></a>Antena patch activa</h3><p>El blog <strong>RTL-SDR.com</strong> puso a la venta en 2019 una antena para banda L que podemos usar para Inmarsat. Podemos adquirirla desde su propia tienda online.<br>Se trata de una antena activa que amplifica y filtra la señal, por lo que no necesitaremos un LNA.</p>
<table>
<thead>
<tr>
<th>Frecuencia</th>
<th>Ganancia</th>
<th>Especificaciones</th>
</tr>
</thead>
<tbody><tr>
<td>1525 – 1637 MHz</td>
<td>-</td>
<td><a href="https://www.rtl-sdr.com/preorder-sale-active-l-band-1525-1637-inmarsat-to-iridium-patch-antenna-set-for-34-95/" target="_blank" rel="noopener">RTL-SDR</a></td>
</tr>
</tbody></table>
<img src="/2020/03/06/recepcion-inmarsat/antena_activa.jpg" class="" title="Antena de RTL-SDR.com">


<h3 id="Antena-helicoidal"><a href="#Antena-helicoidal" class="headerlink" title="Antena helicoidal"></a>Antena helicoidal</h3><p>Este tipo de antenas se pueden utilizar en combinación con un reflector parabólico o directamente. En los siguientes enlaces podemos ver ambas opciones con ganancias entre comprendidas entre 10 dBi y 16 dBi.</p>
<ul>
<li><p><a href="http://www.satellitenwelt.de/l-band.htm" target="_blank" rel="noopener">Antena helicoidal</a>.</p>
<img src="/2020/03/06/recepcion-inmarsat/antena_helix.jpg" class="" title="Antena helicoidal">
</li>
<li><p><a href="https://diebastelkammer.wordpress.com/2014/09/21/helix-antenne-fur-parabolspiegel-um-inmarsat-zu-empfangen/" target="_blank" rel="noopener">Antena helicoidal con reflector parabólico</a>.</p>
<img src="/2020/03/06/recepcion-inmarsat/antena_helix_parabolica.jpg" class="" title="Antena helicoidal + parabólica">


</li>
</ul>
<h3 id="Antena-helicoidal-cuadrifilar"><a href="#Antena-helicoidal-cuadrifilar" class="headerlink" title="Antena helicoidal cuadrifilar"></a>Antena helicoidal cuadrifilar</h3><p>Estas antenas también nos permiten recibir en la banda L. En el siguiente enlace podemos ver como se pueden usar antenas recicladas de radiosondas Vaisala RS92 para recibir la señal del satélite.</p>
<p><a href="https://rfhead.net/archives/665" target="_blank" rel="noopener">Re-purposing Vaisala RS92 Radiosondes as L-Band Active Antennae</a></p>
<img src="/2020/03/06/recepcion-inmarsat/antena_qfh.jpg" class="" title="Radiosonda Vaisala">


<h2 id="Amplificacion-de-la-senal"><a href="#Amplificacion-de-la-senal" class="headerlink" title="Amplificación de la señal"></a>Amplificación de la señal</h2><p>Si usamos una antena pasiva para la recepción de señales desde el satélite Inmarsat, vamos a necesitar amplificarla para poder recibirla correctamente. Para ello usaremos un amplificador o LNA. Existen distintos tipos de LNA que abarcan también la banda L, y además existen modelos específicos para Inmarsat.<br>Nooelec ofrece dos modelos de LNA para Inmarsat que podemos adquirir desde su tienda en Estados Unidos o desde Amazon España.</p>
<h3 id="Nooelec-SAWbird-iO"><a href="#Nooelec-SAWbird-iO" class="headerlink" title="Nooelec SAWbird iO"></a>Nooelec SAWbird iO</h3><p>Este modelo de LNA incorpora filtro SAW centrado en la frecuencia en la que tenemos los servicios de Inmarsat y se alimenta mediante Bias-T.</p>
<img src="/2020/03/06/recepcion-inmarsat/lna.jpg" class="" title="Nooelec SAWbird iO">

<h3 id="Nooelec-SAWbird-iO-1"><a href="#Nooelec-SAWbird-iO-1" class="headerlink" title="Nooelec SAWbird+ iO"></a>Nooelec SAWbird+ iO</h3><p>Este modelo mejora el filtro de la versión anterior y añade otras dos opciones para poder alimentarlo. Además de la opción de alimentarlo mediante Bias-T, incorpora dos pines para conectarle alimentación externa y también un conector micro-USB para alimentarlo por USB. También ofrece una versión <em>Premium</em> con caja metálica.<br><strong>Este modelo necesita un DC block para poder usarse con dispositivos SDR que no lleven diodo de protección ESD.</strong> De lo contrario, tendremos paso de corriente desde el LNA al dispositivo SDR y no podremos recibir la señal correctamente. Los últimos modelos de Nooelec NESDR SMArt llevan este filtro, pero la mayoría de dispositivos, como por ejemplo el V3 de RTL-SDR.com, no lo llevan.</p>
<img src="/2020/03/06/recepcion-inmarsat/lna2.jpg" class="" title="Nooelec SAWbird+ iO">

<h2 id="Recepcion"><a href="#Recepcion" class="headerlink" title="Recepción"></a>Recepción</h2><p>Para recibir la señal basta con apuntar nuestra antena a cualquiera de los satélites de los que tengamos cobertura. En España tenemos cobertura del satélite <strong>Inmarsat-4A F4 (Alphasat)</strong> en 24.8°E y del <strong>Inmarsat-3 F5</strong> en 54°O.</p>
<img src="/2020/03/06/recepcion-inmarsat/inmarsat.jpg" class="" title="Inmarsat">

<p>Ahora iniciamos SDR#, subimos la ganancia del SDR al máximo y ajustamos la antena hasta recibir el máximo posible de señal.</p>
<img src="/2020/03/06/recepcion-inmarsat/sdrsharp.jpg" class="" title="SDR# Inmarsat">
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>Inmarsat</tag>
        <tag>L-Band</tag>
      </tags>
  </entry>
  <entry>
    <title>Recepción del satélite FUNcube-1</title>
    <url>/2020/02/22/recepcion-funcube1/</url>
    <content><![CDATA[<p>El satélite FUNcube-1 es un <a href="https://es.wikipedia.org/wiki/CubeSat" target="_blank" rel="noopener">CubeSat</a> construido por AMSAT-UK con fines educativos.<br>Como parte de su misión, FUNcube-1 está equipado con distintos sensores que monitorizan el estado del satélite y envía la telemetría por radio. Estos datos pueden ser recibidos con nuestros dispositivos SDR y en este artículo veremos como recibirlos y decodificarlos.</p>
<a id="more"></a>

<h2 id="Datos-del-satelite"><a href="#Datos-del-satelite" class="headerlink" title="Datos del satélite"></a>Datos del satélite</h2><table>
<thead>
<tr>
<th>Satélite</th>
<th>FUNcube-1 (AO-73)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Operador</strong></td>
<td>AMSAT-UK</td>
</tr>
<tr>
<td><strong>NORAD ID</strong></td>
<td>39444</td>
</tr>
<tr>
<td><strong>COSPAR ID</strong></td>
<td>2013-066AE</td>
</tr>
<tr>
<td><strong>Tamaño</strong></td>
<td>1U CubeSat (0,98 Kg)</td>
</tr>
<tr>
<td><strong>Lanzamiento</strong></td>
<td>21 de Noviembre de 2013</td>
</tr>
<tr>
<td><strong>Señal</strong></td>
<td>145.935 MHz (1200 bps BPSK)</td>
</tr>
<tr>
<td><strong>Web</strong></td>
<td><a href="https://funcube.org.uk/" target="_blank" rel="noopener">https://funcube.org.uk/</a></td>
</tr>
</tbody></table>
<h2 id="Recepcion"><a href="#Recepcion" class="headerlink" title="Recepción"></a>Recepción</h2><p>FUNcube-1 envía los datos de telemetría en la frecuencia <strong>145.935 MHz</strong>. Para recibir la señal debemos realizar los pasos habituales para el seguimiento de satélites que ya vimos en el artículo <a href="https://sdr-es.com/2020/02/18/ajuste-frecuencia-doppler-orbitron/">“Ajuste de frecuencia en recepción de satélites”</a>.</p>
<p>Los datos para DDETracker son los siguientes:</p>
<p><strong>AOS:</strong><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">radio_Start</span><br><span class="line">radio_modulation_type&lt;USB&gt;</span><br><span class="line">radio_bandwidth_Hz&lt;4800&gt;</span><br><span class="line">radio_center_frequency_Hz&lt;145935000&gt;</span><br><span class="line">radio_tracking_frequency_On</span><br></pre></td></tr></table></figure><br></br></p>
<img src="/2020/02/22/recepcion-funcube1/SDRSharp_FUNcube1.png" class="" title="SDRSharp FUNcube-1">


<h2 id="Decodificacion"><a href="#Decodificacion" class="headerlink" title="Decodificación"></a>Decodificación</h2><p>Para decodificar los datos de telemetría vamos a utilizar el software que AMSAT nos facilita para este satélite. Podemos descargarlo desde el siguiente enlace:</p>
<p><a href="http://download.funcube.org.uk/FUNcube_Dashboard_v1044.msi" target="_blank" rel="noopener"><center>FUNcube-1 Dashboard v1044</center></a></p>
<p>Una vez descargado, lo instalamos como cualquier aplicación de Windows y lo iniciamos.</p>
<p>El siguiente paso es configurarlo. Para ello hacemos click en <strong>“File”</strong> y después <strong>“Settings…”</strong>. Esto nos abre la pestaña de configuración del programa.<br>Ahora debemos indicarle que le vamos a pasar el audio desde SDR#, así que seleccionamos nuestro <a href="https://sdr-es.com/2020/01/21/instalacion-virtual-cable-audio/">cable de audio virtual</a> en la opción <strong>“Input Device”</strong>.</p>
<img src="/2020/02/22/recepcion-funcube1/FUNcube1_Dashboard_config.png" class="" title="FUNcube1 Dashboard Configuración">

<p>Hacemos click en <strong>“Save”</strong> y ya tendremos el programa listo para recibir la señal desde SDR#.<br>Para iniciar el procesamiento de señal hacemos click en <strong>“Capture”</strong> y <strong>“Capture From Soundcard”</strong>. Ahora cuando el satélite comience a recibirse en SDR#, podremos ver los datos en tiempo real en el programa.</p>
<p><em>Telemetría:</em></p>
<img src="/2020/02/22/recepcion-funcube1/FUNcube1_Dashboard_telem.png" class="" title="FUNcube1 Dashboard Telemetría">

<p><em>Mensajes:</em></p>
<img src="/2020/02/22/recepcion-funcube1/FUNcube1_Dashboard_messages.png" class="" title="FUNcube1 Dashboard Mensajes">
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
        <tag>Cubesat</tag>
      </tags>
  </entry>
  <entry>
    <title>Recepción de satélites meteorológicos NOAA</title>
    <url>/2020/03/20/recepcion-satelites-meteorologicos-NOAA/</url>
    <content><![CDATA[<p>Actualmente existen infinidad de satélites meteorológicos orbitando la Tierra. La mayoría de ellos envían sus imágenes y datos encriptados a las estaciones terrestres, pero existen otros satélites de los que es posible recibir sus imágenes de forma sencilla utilizando un dispositivo SDR. En este artículo veremos como recibir imágenes de los satélites meteorológicos NOAA. Estos satélites pertenecen a la agencia científica estadounidense NOAA (<em>National Oceanic and Atmospheric Administration</em>). Orbitan en una órbita polar y tienen como finalidad recoger datos atmosféricos tales como imágenes de las nubes y superficie terrestre, temperatura y humedad atmosférica y los niveles de ozono en las capas altas de la atmósfera.</p>
<p>Estos satélites envían la información en diferentes frecuencias y modulaciones. En este articulo veremos como recibir las imágenes de baja resolución en formato <a href="https://en.wikipedia.org/wiki/Automatic_picture_transmission" target="_blank" rel="noopener">APT</a>.</p>
<a id="more"></a>

<img src="/2020/03/20/recepcion-satelites-meteorologicos-NOAA/apt.jpg" class="" width="500" title="Imagen APT de satélite NOAA">


<h2 id="Datos-de-los-satelites"><a href="#Datos-de-los-satelites" class="headerlink" title="Datos de los satélites"></a>Datos de los satélites</h2><p>Actualmente podemos recibir imágenes APT desde los siguientes satélites meteorológicos NOAA.</p>
<table>
<thead>
<tr>
<th>Satélite</th>
<th>NOAA 15</th>
<th>NOAA 18</th>
<th>NOAA 19</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NORAD ID</strong></td>
<td>25338</td>
<td>28654</td>
<td>33591</td>
</tr>
<tr>
<td><strong>COSPAR ID</strong></td>
<td>1998-030A</td>
<td>2005-018A</td>
<td>2009-005A</td>
</tr>
<tr>
<td><strong>Masa de lanzamiento</strong></td>
<td>1.457 Kg</td>
<td>1.457 Kg</td>
<td>1.440 Kg</td>
</tr>
<tr>
<td><strong>Fecha de lanzamiento</strong></td>
<td>13 de Mayo de 1998</td>
<td>20 de Mayo de 2005</td>
<td>6 de Febrero de 2009</td>
</tr>
<tr>
<td><strong>Señal APT</strong></td>
<td>137,620 MHz</td>
<td>137,9125 MHz</td>
<td>137,100 MHz</td>
</tr>
</tbody></table>
<h2 id="Instalacion-de-WXtoImg"><a href="#Instalacion-de-WXtoImg" class="headerlink" title="Instalación de WXtoImg"></a>Instalación de WXtoImg</h2><p>Existen diferentes programas y utilidades para decodificar la señal APT de estos satélites. En este artículo vamos a utilizar <strong>SDR#</strong> y el software <strong>WXtoImg</strong> para Windows. Podemos descargarlo desde el siguiente enlace:</p>
<p><a href="https://wxtoimgrestored.xyz/" target="_blank" rel="noopener"><center>https://wxtoimgrestored.xyz/</center></a></p>
<p>Una vez descargado e instalado, realizaremos los siguientes pasos para configurarlo:</p>
<ol>
<li>Introducir los datos de nuestra ubicación. Estos datos los necesita WXtoImg para calcular los pases de los satélites y para colocar la capa de líneas con los contornos. Cuanto más ajustados sean estos valores, mejor se ajustará esta capa a la imagen. Para introducirlos vamos a <em><strong>&quot;Options&quot;</strong></em> y <em><strong>&quot;Ground Station Location…&quot;</strong></em>. En esta ventana introducimos nuestras coordenadas y altitud.</li>
</ol>
<img src="/2020/03/20/recepcion-satelites-meteorologicos-NOAA/wx_ground.jpg" class="" title="WXtoImg">

<ol start="2">
<li>Ajustes de grabación. Tenemos que indicarle a WXtoImg que le vamos a pasar la señal desde SDR# mediante el cable de audio virtual. Para ellos vamos a <em><strong>&quot;Options&quot;</strong></em> y <em><strong>&quot;Recording Options&quot;</strong></em>. Aquí seleccionamos nuestro cable de audio virtual.</li>
</ol>
<img src="/2020/03/20/recepcion-satelites-meteorologicos-NOAA/wx_recording.jpg" class="" title="WXtoImg">

<ol start="3">
<li>Marcamos la opción de resincronizado en <em><strong>&quot;Options&quot;</strong></em>, <em><strong>&quot;Resync&quot;</strong></em>.</li>
</ol>
<img src="/2020/03/20/recepcion-satelites-meteorologicos-NOAA/wx_resync.jpg" class="" title="WXtoImg">

<ol start="4">
<li>Podemos hacer que WXtoImg nos genere las imágenes que queramos añadiendo los datos de la telemetría una vez termine de recibir la imagen del satélite. Para ello vamos a <em><strong>&quot;Options&quot;</strong></em>, <em><strong>&quot;Auto Processing Options…&quot;</strong></em> y marcamos <em><strong>&quot;Create image(s)&quot;</strong></em>. Después hacemos click en <em><strong>&quot;Image Settings…&quot;</strong></em> y elegimos las imágenes que queramos.</li>
</ol>
<img src="/2020/03/20/recepcion-satelites-meteorologicos-NOAA/wx_record.jpg" class="" title="WXtoImg">

<ol start="5">
<li>Por último actualizamos los datos de posición de los satélites en WXtoImg. Vamos a <em><strong>&quot;File&quot;</strong></em> y hacemos click en <em><strong>&quot;Update Keplers&quot;</strong></em>. Una vez se actualicen, el programa nos mostrará en la parte inferior de la ventana la información del siguiente pase sobre nuestra ubicación.</li>
</ol>
<img src="/2020/03/20/recepcion-satelites-meteorologicos-NOAA/wx_siguiente.jpg" class="" title="WXtoImg">


<h2 id="Recepcion"><a href="#Recepcion" class="headerlink" title="Recepción"></a>Recepción</h2><p>Para recibir la señal debemos realizar los pasos habituales para el seguimiento de satélites que ya vimos en el artículo <a href="https://sdr-es.com/2020/02/18/ajuste-frecuencia-doppler-orbitron/">“Ajuste de frecuencia en recepción de satélites”</a>.</p>
<p>Los datos para DDETracker son los siguientes:</p>
<p><strong>AOS:</strong><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">radio_Start</span><br><span class="line">radio_modulation_type&lt;wfm&gt;</span><br><span class="line">radio_bandwidth_Hz&lt;36000&gt;</span><br><span class="line">radio_tracking_frequency_On</span><br></pre></td></tr></table></figure></p>
<p>Para recibir el pase tenemos que sacar el audio de SDR# mediante el cable de audio virtual y tener WXtoImg abierto. Una vez el satélite comience a verse sobre el horizonte, SDR# iniciará el seguimiento y WXtoImg comenzará a recibir y procesar la señal.</p>
<img src="/2020/03/20/recepcion-satelites-meteorologicos-NOAA/sdr_sharp.jpg" class="" title="SDR#">

<p>Es importante asegurarse que el volumen de la salida de SDR# sea el adecuado. Podemos ver el nivel que llega a WXtoImg en la esquina inferior derecha. Para que la imagen se genere correctamente, el indicador de nivel de volumen debe mantenerse en color verde durante todo el pase.</p>
<img src="/2020/03/20/recepcion-satelites-meteorologicos-NOAA/wx_recibiendo.jpg" class="" title="WXtoImg">

<p>Al finalizar el pase WXtoImg dejara de grabar y generará las imágenes que le hemos indicado en el paso 4 de la configuración.</p>
<img src="/2020/03/20/recepcion-satelites-meteorologicos-NOAA/wx_terminado.jpg" class="" title="WXtoImg">
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
        <tag>Satélites meteorológicos</tag>
      </tags>
  </entry>
  <entry>
    <title>Recepción del satélite JY1-SAT</title>
    <url>/2020/02/25/recepcion-jy1sat/</url>
    <content><![CDATA[<p>El satélite JY1-SAT es un CubeSat construido por estudiantes de varias universidades de Jordania y financiado por la Jordan’s Crown Prince Foundation.<br>JY1-SAT se basa en la plataforma FUNCube, por lo que también se identifica como FUNcube-6. Además de las funciones habituales de FUNcube, el satélite envía imágenes en formato SSDV.<br>En este artículo veremos como recibir la telemetría y las imágenes.</p>
<a id="more"></a>

<h2 id="Datos-del-satelite"><a href="#Datos-del-satelite" class="headerlink" title="Datos del satélite"></a>Datos del satélite</h2><table>
<thead>
<tr>
<th>Satélite</th>
<th>JY1-SAT (JO-97)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Operador</strong></td>
<td>Crown Prince Foundation</td>
</tr>
<tr>
<td><strong>NORAD ID</strong></td>
<td>43803</td>
</tr>
<tr>
<td><strong>COSPAR ID</strong></td>
<td>2018-099AX</td>
</tr>
<tr>
<td><strong>Tamaño</strong></td>
<td>1U CubeSat (1.11 Kg)</td>
</tr>
<tr>
<td><strong>Lanzamiento</strong></td>
<td>3 de Diciembre de 2018</td>
</tr>
<tr>
<td><strong>Señal</strong></td>
<td>145.840 MHz (1200 bps BPSK)</td>
</tr>
<tr>
<td><strong>Web</strong></td>
<td><a href="https://www.cpf.jo/en/our-initiatives/masar" target="_blank" rel="noopener">https://www.cpf.jo/en/our-initiatives/masar</a></td>
</tr>
</tbody></table>
<h2 id="Recepcion"><a href="#Recepcion" class="headerlink" title="Recepción"></a>Recepción</h2><p>JY1-SAT envía los datos de telemetría y las imágenes en la frecuencia <strong>145.840 MHz</strong>. Para recibir la señal debemos realizar los pasos habituales para el seguimiento de satélites.</p>
<p>Los datos para DDETracker son los siguientes:</p>
<p><strong>AOS:</strong><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">radio_Start</span><br><span class="line">radio_modulation_type&lt;USB&gt;</span><br><span class="line">radio_bandwidth_Hz&lt;4800&gt;</span><br><span class="line">radio_center_frequency_Hz&lt;145840000&gt;</span><br><span class="line">radio_tracking_frequency_On</span><br></pre></td></tr></table></figure><br></br></p>
<img src="/2020/02/25/recepcion-jy1sat/sdrsharp.png" class="" title="SDRSharp JY1-SAT">


<h2 id="Decodificacion"><a href="#Decodificacion" class="headerlink" title="Decodificación"></a>Decodificación</h2><p>Al ser un proyecto basado en FUNcube, el software es muy similar al que ya hemos usado para el <a href="https://sdr-es.com/2020/02/22/recepcion-funcube1/">FUNcube-1</a>. Podemos descargarlo desde el siguiente enlace:</p>
<p><a href="https://download.funcube.org.uk/JY1Sat_Dashboard_v1189.msi" target="_blank" rel="noopener"><center>JY1Sat Dashboard v1189</center></a></p>
<p>Una vez descargado, lo instalamos como cualquier aplicación de Windows y lo iniciamos.</p>
<p>El siguiente paso es configurarlo. Para ello hacemos click en <strong>“File”</strong> y después <strong>“Settings…”</strong>. Esto nos abre la pestaña de configuración del programa.<br>Ahora debemos indicarle que le vamos a pasar el audio desde SDR#, así que seleccionamos nuestro <a href="https://sdr-es.com/2020/01/21/instalacion-virtual-cable-audio/">cable de audio virtual</a> en la opción <strong>“Input Device”</strong>.</p>
<img src="/2020/02/25/recepcion-jy1sat/config.png" class="" title="JY1-SAT Dashboard Configuración">

<p>Hacemos click en <strong>“Save”</strong> y ya tendremos el programa listo para recibir la señal desde SDR#.<br>Para iniciar el procesamiento de señal hacemos click en <strong>“Capture”</strong> y <strong>“Capture From Soundcard”</strong>. Ahora cuando el satélite comience a recibirse en SDR#, podremos ver los datos en tiempo real en el programa.</p>
<p><em>Telemetría:</em></p>
<img src="/2020/02/25/recepcion-jy1sat/telem.png" class="" title="JY1-SAT Dashboard Telemetría">

<p><em>Imágenes:</em></p>
<img src="/2020/02/25/recepcion-jy1sat/images.png" class="" title="JY1-SAT Dashboard Mensajes">


<p>Las imágenes necesitan algunos pases para recibirlas completamente.</p>
<img src="/2020/02/25/recepcion-jy1sat/JY1SatAudioId7.jpg" class="" title="JY1SatAudioId7">
</br>
<img src="/2020/02/25/recepcion-jy1sat/JY1SatAudioId8.jpg" class="" title="JY1SatAudioId8">
</br>
<img src="/2020/02/25/recepcion-jy1sat/JY1SatAudioId9.jpg" class="" title="JY1SatAudioId9">
</br>
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
        <tag>Cubesat</tag>
      </tags>
  </entry>
  <entry>
    <title>Recepción de satélites meteorológicos Meteor-M</title>
    <url>/2020/03/27/recepcion-satelites-meteorologicos-meteor/</url>
    <content><![CDATA[<p>Tras varios años de desarrollo y pruebas, en 1969 se presentó en la antigua URSS la familia de satélites meteorológicos Meteor. Como muchos de los avances tecnológicos soviéticos de esa época, estos satélites tenían un doble propósito, siendo el principal el militar. Durante la Guerra Fría, la unión soviética necesitaba conocer las condiciones meteorológicas actualizadas en todo el mundo para la coordinación de sus bombarderos y flota naval. Tras la presión por parte de los militares, que veían que Estados Unidos creaba sus sistemas de predicción meteorológica vía satélite, la unión soviética decidió finalmente crear su propia red de satélites meteorológicos.</p>
<p>La serie Meteor-M fue planificada para la primera década del siglo XXI e incluiría tres nuevos satélites con dos diseños diferentes. El objetivo principal de los dos primeros satélites (Meteor-M N1 y Meteor-M N2) sería proveer de información meteorológica, así como la monitorización de la capa de ozono, los niveles de radiación en el espacio y la observación de los mares y la capa de hielo. El tercero (Meteor-M N3) incorporaría una antena radar de nueva generación para la observación oceánica.<br>Estos satélites transmiten imágenes en formato <a href="https://en.wikipedia.org/wiki/Low-rate_picture_transmission" target="_blank" rel="noopener">LRPT</a> en 137 MHz y en formato <a href="https://en.wikipedia.org/wiki/High-resolution_picture_transmission" target="_blank" rel="noopener">HRPT</a> en 1,7 GHz. En este articulo veremos como recibir la señal con nuestro dispositivo SDR y obtener las imágenes LRPT.</p>
<a id="more"></a>

<img src="/2020/03/27/recepcion-satelites-meteorologicos-meteor/Meteor-M_2.jpg" class="" width="600" title="Meteor-M N2-1">

<p>Más información sobre los satélites Meteor-M en <a href="http://www.russianspaceweb.com/meteor-m.html" target="_blank" rel="noopener">este enlace</a> (en inglés).</p>
<h2 id="Datos-de-los-satelites"><a href="#Datos-de-los-satelites" class="headerlink" title="Datos de los satélites"></a>Datos de los satélites</h2><p>Tenemos en órbita tres satélites Meteor-M, pero actualmente solo uno de ellos emite imágenes en LRPT. El último satélite puesto en órbita sufrió a finales de 2019 el impacto de un micro-meteorito que le produjo daños y dejó el sistema de LRPT fuera de servicio. Solo consiguieron restablecer el sistema de HRPT. <a href="https://www.roscosmos.ru/27891/" target="_blank" rel="noopener">Enlace a la publicación de Roscosmos.</a></p>
<table>
<thead>
<tr>
<th>Satélite</th>
<th>Meteor-M N1</th>
<th>Meteor-M N2</th>
<th>Meteor-M N2-2</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NORAD ID</strong></td>
<td>35865</td>
<td>40069</td>
<td>44387</td>
</tr>
<tr>
<td><strong>COSPAR ID</strong></td>
<td>2009-049A</td>
<td>2014-037A</td>
<td>2019-038A</td>
</tr>
<tr>
<td><strong>Masa de lanzamiento</strong></td>
<td>2.900 Kg</td>
<td>2.900 Kg</td>
<td>2.900 Kg</td>
</tr>
<tr>
<td><strong>Fecha de lanzamiento</strong></td>
<td>17 de Septiembre de 2009</td>
<td>8 de Julio de 2014</td>
<td>5 de Julio de 2019</td>
</tr>
<tr>
<td><strong>Señal LRPT</strong></td>
<td>Inactivo</td>
<td>137,100 MHz</td>
<td>Averiado</td>
</tr>
</tbody></table>
<p>Podemos conocer el estado actual de los satélites en la siguiente página: <a href="http://happysat.nl/Meteor/html/Meteor_Status.html" target="_blank" rel="noopener">Meteor Status (por Happysat)</a>.</p>
<h2 id="Instalacion-de-Meteor-Demodulator"><a href="#Instalacion-de-Meteor-Demodulator" class="headerlink" title="Instalación de Meteor Demodulator"></a>Instalación de Meteor Demodulator</h2><p>Vamos a instalar un <em>plugin</em> para SDR# que nos permitirá demodular la señal del satélite en tiempo real. Existen otras formas de demodular dicha señal mediante otro software utilizando la grabación de banda base, pero nos podemos ahorrar estos pasos usando el <em>plugin</em> <strong>Meteor Demodulator</strong>. Para instalarlo seguiremos los siguientes pasos:</p>
<ol>
<li><p>Descargar el plugin desde el siguiente enlace:<br> <a href="http://rtl-sdr.ru/uploads/download/meteor.zip" target="_blank" rel="noopener"><center>Meteor Demodulator v2.3</center></a></p>
</li>
<li><p>Extraemos el contenido del archivo ZIP descargado y copiamos los archivos <em><strong>SDRSharp.PluginsCom.dll</strong></em> y <em><strong>SDRSharp.Meteor.dll</strong></em> dentro del directorio de instalación de SDR#.</p>
</li>
<li><p>Insertamos la siguiente línea dentro del archivo <em><strong>Plugins.xml</strong></em> que encontraremos dentro de la carpeta de SDR#.</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">add</span> <span class="attr">key</span>=<span class="string">"Meteor"</span> <span class="attr">value</span>=<span class="string">"SDRSharp.Meteor.MeteorPlugin,SDRSharp.Meteor"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Iniciamos SDR# y desplegamos el nuevo <em>plugin</em>.</p>
 <img src="/2020/03/27/recepcion-satelites-meteorologicos-meteor/meteor_plugin.jpg" class="" title="SDR#">

<p> Los ajustes que vamos a utilizar son:</p>
<ul>
<li><p><strong>Modulation type</strong>: aquí le indicamos el tipo de modulación de pendiendo del satélite. Este ajuste lo haremos de forma automática desde DDE Tracker.</p>
</li>
<li><p><strong>SymbolRate</strong>: el satélite usa los modos 72K y 80K de forma aleatoria. Lo dejaremos en <strong>Auto</strong> para que lo detecte automático.</p>
</li>
<li><p><strong>Tracking</strong>: lo marcamos para corregir el efecto <em>Doppler</em> en la señal.</p>
<p>En <em>Output</em> marcamos la opción que vayamos a utilizar para sacar los datos (podemos marcar ambas). Las opciones que tenemos son:</p>
</li>
<li><p><strong>TCP Socket</strong>: levanta un socket TCP al que el programa <strong>LRPT Decoder</strong> se conectará y recibirá los datos para decodificar la imagen en tiempo real.</p>
</li>
<li><p><strong>File</strong>: genera un archivo con los datos para procesarlos posteriormente con <strong>LRPT Decoder</strong>. La ubicación de este archivo se la indicamos haciendo click en <em><strong>Configure</strong></em> y <em><strong>Select folder</strong></em>.</p>
<img src="/2020/03/27/recepcion-satelites-meteorologicos-meteor/meteor_plugin_config.png" class="" title="Meteor Demodulator">

</li>
</ul>
</li>
</ol>
<h2 id="Instalacion-de-LRPT-Decoder"><a href="#Instalacion-de-LRPT-Decoder" class="headerlink" title="Instalación de LRPT Decoder"></a>Instalación de LRPT Decoder</h2><p>El programa LRPT Decoder nos va a permitir decodificar los datos obtenidos con el demodulador de Meteor y generar la imagen.<br>Para descargarlo hacemos click en el siguiente enlace y simplemente extraemos su contenido.</p>
<p><a href="http://happysat.nl/LRPT_Decoder_v56.zip" target="_blank" rel="noopener"><center>M2 LRPT Decoder V56</center></a></p>
<p>Como vimos en el apartado anterior, LRPT Decoder es capaz de procesar los datos desde dos fuentes distintas, ya sea desde el socket TCP o desde un archivo. Dependiendo de la opción que elijamos debemos modificar el archivo de configuración <em><strong>M2_LRPT_Decoder.ini</strong></em> de una forma u otra. A continuación veremos los ajustes para cada una de las opciones.</p>
<ul>
<li>Ajustes para decodificar mediante <strong>socket</strong>:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[IN]</span><br><span class="line">source&#x3D;TCP</span><br><span class="line">mode&#x3D;auto</span><br><span class="line">sat&#x3D;auto</span><br><span class="line">host&#x3D;localhost</span><br><span class="line">port&#x3D;2011</span><br><span class="line"></span><br><span class="line">[OUT]</span><br><span class="line">rgb&#x3D;123.jpg</span><br><span class="line">rgb_q&#x3D;100</span><br><span class="line">mono&#x3D;yes</span><br><span class="line">logs&#x3D;no</span><br><span class="line">APID70&#x3D;no</span><br><span class="line">VCDU&#x3D;no</span><br><span class="line">path&#x3D;C:\SDR\MeteorM2\imágenes</span><br><span class="line"></span><br><span class="line">[FAST]</span><br><span class="line">FORMAT&#x3D;jpg</span><br><span class="line">R&#x3D;1</span><br><span class="line">G&#x3D;2</span><br><span class="line">B&#x3D;3</span><br></pre></td></tr></table></figure>

<ul>
<li>Ajustes para decodificar mediante <strong>archivo</strong>:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[IN]</span><br><span class="line">source&#x3D;man</span><br><span class="line">sat&#x3D;M2</span><br><span class="line">mode&#x3D;72k</span><br><span class="line"></span><br><span class="line">[OUT]</span><br><span class="line">rgb&#x3D;123.jpg</span><br><span class="line">rgb_q&#x3D;100</span><br><span class="line">mono&#x3D;yes</span><br><span class="line">logs&#x3D;no</span><br><span class="line">APID70&#x3D;yes</span><br><span class="line">VCDU&#x3D;no</span><br><span class="line">path&#x3D;C:\SDR\MeteorM2\imágenes</span><br><span class="line"></span><br><span class="line">[FAST]</span><br><span class="line">FORMAT&#x3D;jpg</span><br><span class="line">R&#x3D;1</span><br><span class="line">G&#x3D;2</span><br><span class="line">B&#x3D;3</span><br></pre></td></tr></table></figure>

<h2 id="Recepcion"><a href="#Recepcion" class="headerlink" title="Recepción"></a>Recepción</h2><p>Para recibir la señal debemos realizar los pasos habituales para el seguimiento de satélites que ya vimos en el artículo <a href="https://sdr-es.com/2020/02/18/ajuste-frecuencia-doppler-orbitron/">“Ajuste de frecuencia en recepción de satélites”</a>.</p>
<p>Los datos para DDETracker son los siguientes:</p>
<h3 id="Meteor-M-N2"><a href="#Meteor-M-N2" class="headerlink" title="Meteor-M N2"></a>Meteor-M N2</h3><p><strong>AOS:</strong><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">radio_Start</span><br><span class="line">radio_modulation_type&lt;wfm&gt;</span><br><span class="line">radio_center_frequency_Hz&lt;137100000&gt;</span><br><span class="line">radio_frequency_Hz&lt;137100000&gt;</span><br><span class="line">radio_bandwidth_Hz&lt;100000&gt;</span><br><span class="line">QPSK_demodulator_Start</span><br><span class="line">send_tracking_frequency_On</span><br><span class="line">start_programm_Path&lt;C:\SDR\MeteorM2\Decoder\M2_LRPT_Decoder.exe&gt;</span><br></pre></td></tr></table></figure></p>
<p>En este ejemplo se ha usado la opción de enviar los datos por socket, por lo que en los ajustes anteriores se ha añadido el comando <strong>start_programm_Path</strong> para que se inice LRPT Decoder de forma automática cuando se inicie el seguimiento. Si optamos por la decodificación desde el archivo, este comando no es necesario.</p>
<p>Una vez configurado todo correctamente, en el instante en el que el satélite comience a verse por nuestra localización, comenzará el seguimiento automático.</p>
<img src="/2020/03/27/recepcion-satelites-meteorologicos-meteor/sdr_sharp_preparado.jpg" class="" width="900" title="SDR#">

<p>En el momento en que la señal sea detectada por el <em>plugin</em>, este comenzará a demodularla y a procesarla. Veremos que aparece <em><strong>Locked</strong></em> en la interfaz.</p>
<img src="/2020/03/27/recepcion-satelites-meteorologicos-meteor/sdr_sharp_inicio.jpg" class="" width="900" title="SDR#">
</br>
<img src="/2020/03/27/recepcion-satelites-meteorologicos-meteor/sdr_sharp_recibiendo.jpg" class="" width="900" title="SDR#">

<p>Durante el pase podemos ver como LRPT Decoder genera la imagen si hemos optado por sacar los datos por el socket.</p>
<img src="/2020/03/27/recepcion-satelites-meteorologicos-meteor/meteor_analizer.jpg" class="" width="900" title="LRPT Decoder">

<p>Una vez termine el pase vamos a LRPT Decoder para generar la imagen final. El satélite tiene seis canales de los cuales utiliza tres de forma simultanea. Los tres primeros corresponden a espectro visible y los tres últimos al espectro infrarrojo. A veces podemos encontrar los tres canales del espectro visible o bien dos del visible uno del infrarrojo. La imagen final a color se puede componer uniendo los tres canales RGB del espectro visible, o bien con dos de ellos.</p>
<img src="/2020/03/27/recepcion-satelites-meteorologicos-meteor/meteor_analizer_finalizado.jpg" class="" width="900" title="LRPT Decoder">

<p>Para generarla seleccionamos los canales y hacemos click en <strong>Generate RGB</strong>. Nos aparecerá una ventana con la vista previa. Ahora hacemos click en <strong>Save</strong> y seleccionamos el formato de salida de la imagen que se guardará en la ruta que le hemos indicado en el archivo <em><strong>M2_LRPT_Decoder.ini</strong></em>.</p>
<img src="/2020/03/27/recepcion-satelites-meteorologicos-meteor/meteor_analizer_guardar.jpg" class="" title="LRPT Decoder">

<h2 id="Correccion-de-la-distorsion-de-la-imagen"><a href="#Correccion-de-la-distorsion-de-la-imagen" class="headerlink" title="Corrección de la distorsión de la imagen"></a>Corrección de la distorsión de la imagen</h2><p>Si abrimos la imagen que hemos recibido veremos que presenta una distorsión en los laterales de la misma. Esta distorsión es posible corregirla de forma sencilla usando el software <strong>Smooth Meteor</strong> que podemos descargar desde el siguiente enlace:</p>
<p><a href="https://leshamilton.co.uk/soft/smoothmeteor-setup.exe" target="_blank" rel="noopener"><center>Smooth Meteor v1.68</center></a></p>
<p>Una vez lo tengamos instalado, abrimos la imagen y le aplicamos las rectificaciones necesarias.</p>
<img src="/2020/03/27/recepcion-satelites-meteorologicos-meteor/smooth_meteor.jpg" class="" title="Smooth Meteor">
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
        <tag>Satélites meteorológicos</tag>
      </tags>
  </entry>
  <entry>
    <title>Recepción del satélite NAYIF-1</title>
    <url>/2020/02/26/recepcion-nayif1/</url>
    <content><![CDATA[<p>El satélite NAYIF-1 es un CubeSat construido por estudiante de la <em>Emirates Institution for Advanced Science and Technology (EIAST)</em>, en colaboración con la <em>American University of Sharjah (AUS)</em>.<br>NAYIF-1 se basa en la plataforma FUNCube, por lo que también se identifica como FUNcube-5.<br>Este satélite envía datos de telemetría y mensajes que pueden ser recibidos con nuestros dispositivos SDR. En este artículo veremos como recibirlos y decodificarlos.</p>
<a id="more"></a>

<h2 id="Datos-del-satelite"><a href="#Datos-del-satelite" class="headerlink" title="Datos del satélite"></a>Datos del satélite</h2><table>
<thead>
<tr>
<th>Satélite</th>
<th>NAYIF-1 (EO-88)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Operador</strong></td>
<td>EIAST y AUS</td>
</tr>
<tr>
<td><strong>NORAD ID</strong></td>
<td>42017</td>
</tr>
<tr>
<td><strong>COSPAR ID</strong></td>
<td>2017-008BX</td>
</tr>
<tr>
<td><strong>Tamaño</strong></td>
<td>1U CubeSat (1.32 Kg)</td>
</tr>
<tr>
<td><strong>Lanzamiento</strong></td>
<td>15 de Febrero de 2017</td>
</tr>
<tr>
<td><strong>Señal</strong></td>
<td>145.940 MHz (1200 bps BPSK)</td>
</tr>
<tr>
<td><strong>Web</strong></td>
<td><a href="https://www.mbrsc.ae/satellite-programme/nayif-1" target="_blank" rel="noopener">https://www.mbrsc.ae/satellite-programme/nayif-1</a></td>
</tr>
</tbody></table>
<h2 id="Recepcion"><a href="#Recepcion" class="headerlink" title="Recepción"></a>Recepción</h2><p>NAYIF-1 envía los datos de telemetría en la frecuencia <strong>145.940 MHz</strong>. Para recibir la señal debemos realizar los pasos habituales para el seguimiento de satélites.</p>
<p>Los datos para DDETracker son los siguientes:</p>
<p><strong>AOS:</strong><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">radio_Start</span><br><span class="line">radio_modulation_type&lt;USB&gt;</span><br><span class="line">radio_bandwidth_Hz&lt;4800&gt;</span><br><span class="line">radio_center_frequency_Hz&lt;145940000&gt;</span><br><span class="line">radio_tracking_frequency_On</span><br></pre></td></tr></table></figure><br></br></p>
<img src="/2020/02/26/recepcion-nayif1/sdrsharp.png" class="" title="SDRSharp NAYIF-1">


<h2 id="Decodificacion"><a href="#Decodificacion" class="headerlink" title="Decodificación"></a>Decodificación</h2><p>Al ser un proyecto basado en FUNcube, el software es muy similar al que ya hemos usado para el <a href="https://sdr-es.com/2020/02/22/recepcion-funcube1/">FUNcube-1</a> y <a href="https://sdr-es.com/2020/02/25/recepcion-jy1sat/">JY1-SAT</a>. Podemos descargarlo desde el siguiente enlace:</p>
<p><a href="https://download.funcube.org.uk/Nayif-1_Dashboard_1040_Installer.msi" target="_blank" rel="noopener"><center>Nayif-1 Dashboard v1040</center></a></p>
<p>Una vez descargado, lo instalamos como cualquier aplicación de Windows y lo iniciamos.</p>
<p>El siguiente paso es configurarlo. Para ello hacemos click en <strong>“File”</strong> y después <strong>“Settings…”</strong>. Esto nos abre la pestaña de configuración del programa.<br>Ahora debemos indicarle que le vamos a pasar el audio desde SDR#, así que seleccionamos nuestro <a href="https://sdr-es.com/2020/01/21/instalacion-virtual-cable-audio/">cable de audio virtual</a> en la opción <strong>“Input Device”</strong>.</p>
<img src="/2020/02/26/recepcion-nayif1/config.png" class="" title="NAYIF-1 Dashboard Configuración">

<p>Hacemos click en <strong>“Save”</strong> y ya tendremos el programa listo para recibir la señal desde SDR#.<br>Para iniciar el procesamiento de señal hacemos click en <strong>“Capture”</strong> y <strong>“Capture From Soundcard”</strong>. Ahora cuando el satélite comience a recibirse en SDR#, podremos ver los datos en tiempo real en el programa.</p>
<p><em>Telemetría:</em></p>
<img src="/2020/02/26/recepcion-nayif1/telem.png" class="" title="NAYIF-1 Dashboard Telemetría">

<p><em>Mensajes:</em></p>
<img src="/2020/02/26/recepcion-nayif1/messages.png" class="" title="NAYIF-1 Dashboard Mensajes">
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
        <tag>Cubesat</tag>
      </tags>
  </entry>
  <entry>
    <title>Recepción de mensajes Inmarsat STD-C</title>
    <url>/2020/03/09/recepcion-std-c-inmarsat/</url>
    <content><![CDATA[<p>En el artículo <a href="https://sdr-es.com/2020/03/06/recepcion-inmarsat/">“Recepción de satélites Inmarsat”</a> vimos cómo recibir señal desde los satélites Inmarsat. Ahora veremos como decodificar los mensajes que recibimos utilizando Scytale-C, un software Open Source que permite decodificar mensajes SDT-C.<br>Scytale-C tiene distintos tipos de instalación, tanto para SDR# como para GNU Radio. En este artículo veremos como utilizarlo mediante el plugin para SDR# y la interfaz de usuario.</p>
<a id="more"></a>

<p>Lo primero será descargar los binarios desde el repositorio de Scytale-C desde el siguiente link:</p>
<p><a href="https://bitbucket.org/scytalec/scytalec/downloads/" target="_blank" rel="noopener"><center>https://bitbucket.org/scytalec/scytalec/downloads/</center></a></p>
<p>Necesitamos descargar el plugin para SDR# (<strong>x64-SDRSharp.ScytaleC-10213.zip</strong>) y la interfaz de usuario (<strong>x64-ScytaleC.QuickUI-17010.zip</strong>).</p>
<h2 id="Instalacion-del-plugin-en-SDR"><a href="#Instalacion-del-plugin-en-SDR" class="headerlink" title="Instalación del plugin en SDR#"></a>Instalación del plugin en SDR#</h2><p>El siguiente paso es instalar el plugin en SDR#. Para ello basta con extraer el contenido del archivo <strong>x64-SDRSharp.ScytaleC-10213.zip</strong> dentro del directorio de instalación de SDR#. Los dos archivos de texto no son necesarios.</p>
<p>Una vez extraído el contenido, insertamos la siguiente línea de texto dentro del archivo <em><strong>Plugins.xml</strong></em>, que encontraremos dentro de la carpeta de instalación de SDR#.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;add key&#x3D;&quot;ScytaleC&quot; value&#x3D;&quot;SDRSharp.ScytaleC.ScytaleCPlugin,SDRSharp.ScytaleC&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
</br>

<img src="/2020/03/09/recepcion-std-c-inmarsat/scytale_magicline.jpg" class="" title="Magicline de Scytale-C">

<p>Ahora reiniciamos SDR# y tendremos el plugin instalado.</p>
<h2 id="Instalacion-de-la-interfaz-de-usuario-de-Scytale-C"><a href="#Instalacion-de-la-interfaz-de-usuario-de-Scytale-C" class="headerlink" title="Instalación de la interfaz de usuario de Scytale-C"></a>Instalación de la interfaz de usuario de Scytale-C</h2><p>Turno ahora de instalar la interfaz de usuario de Scytale-C. Para ello simplemente extraemos el contenido del archivo <strong>x64-ScytaleC.QuickUI-17010.zip</strong> que hemos descargado anteriormente en el directorio deseado. Por ejemplo en <em>C:/SDR/ScytaleC</em>.</p>
<p>Para iniciar el programa basta con hacer doble click en <strong>ScytaleC.QuickUI.exe</strong>. Al iniciar el programa se muestra un mensaje sobre la confidencialidad que debemos leer detenidamente.</p>
<p><strong>Algunos mensajes que se reciben con Scytale-C van a un destinatario en concreto y pueden contener información sensible. Si no somos los destinatarios de dichos mensajes, debemos proceder a la eliminación de los mismos y no reenviarlos ni publicarlos bajo ningún concepto.</strong></p>
<img src="/2020/03/09/recepcion-std-c-inmarsat/scytale_ui.jpg" class="" title="UI Scytale-C">

<h2 id="Recepcion-y-visualizacion-de-mensajes"><a href="#Recepcion-y-visualizacion-de-mensajes" class="headerlink" title="Recepción y visualización de mensajes"></a>Recepción y visualización de mensajes</h2><p>Vamos ahora a recibir mensajes desde Inmarsat. Si ya tenemos nuestra antena orientada y conectada, iniciamos SDR# y buscamos las frecuencias de SDT-C. En Inmarsat-4A F4 las encontramos en 1.537,100 MHz para NCS y sobre 1.539,500 MHz para los canales LES TDM.</p>
<p>Una vez las tengamos localizadas, sintonizamos una de las señales en modo <strong>USB</strong> y ancho de banda de <strong>4 KHz</strong>.</p>
<p>Iniciamos a continuación el plugin marcando la casilla <em><strong>“Enabled”</strong></em>. También marcamos <em><strong>“Auto Tracking”</strong></em> para que ajuste la señal de forma automática.</p>
<p>Si la señal es buena, veremos que aparece <em><strong>“Locked”</strong></em> en el plugin.</p>
<img src="/2020/03/09/recepcion-std-c-inmarsat/sdrsharp.jpg" class="" title="Plugin Scytale-C">

<p>Con SDR# ya recibiendo la señal correctamente pasamos a la interfaz de usuario de Scytale-C. El plugin y esta interfaz se comunican por UDP de forma local y vienen configurados con el puerto 15003 por defecto.</p>
<p>Para que nos lleguen los mensajes bastaría con hacer click en el botón de Play/Stop. Si todo ha ido bien, comenzaremos a recibirlos.</p>
<img src="/2020/03/09/recepcion-std-c-inmarsat/scytale_messages.jpg" class="" title="Scytale-C Mensajes">
]]></content>
      <tags>
        <tag>Satélites</tag>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
        <tag>Inmarsat</tag>
        <tag>L-Band</tag>
      </tags>
  </entry>
  <entry>
    <title>Recibir radio digital mundial (DRM)</title>
    <url>/2020/10/25/recibir-drm/</url>
    <content><![CDATA[<p><a href="https://www.drm.org/" target="_blank" rel="noopener">Digital Radio Mondiale (DRM)</a>, en español radio digital mundial, es un conjunto de tecnologías de transmisión de audio digital diseñadas para operar sobre las bandas utilizadas actualmente para la radiodifusión analógica en AM (especialmente de onda corta) y FM.<br>DRM ha sido diseñado para poder reutilizar los transmisores analógicos existentes. Las instalaciones como las antenas, alimentadores o amplificadores no necesitan modificación, evitando importantes inversiones.<br>En este artículo veremos como recibir emisiones en el estándar DRM30 con nuestro dispositivo SDR.</p>
<a id="more"></a>

<img src="/2020/10/25/recibir-drm/logo.png" class="" width="300" title="DRM logo">

<p>Encontraremos las emisiones DRM30 por debajo de los 30 MHz. Habitualmente suelen ser emisiones no continuadas, por lo que no necesariamente vamos a encontrar dichas emisiones siempre. Podemos consultar los horarios actualizados de las mismas en el siguiente enlace:</p>
<p><a href="https://www.drm.org/what-can-i-hear/broadcast-schedule-2/" target="_blank" rel="noopener"><center>DRM Broadcast Schedule</center></a></p>
<h2 id="Instalacion-del-software"><a href="#Instalacion-del-software" class="headerlink" title="Instalación del software"></a>Instalación del software</h2><p>En este ejemplo vamos a usar SDR# para recibir la señal y sacar el audio mediante el <a href="/2020/01/21/instalacion-virtual-cable-audio/">cable de audio virtual</a>, aunque también podemos usar cualquier otro programa. Para recibir DRM usaremos el software <a href="https://sourceforge.net/projects/drm/" target="_blank" rel="noopener">Dream AM/DRM Receiver</a> que podemos descargar desde el siguiente enlace:</p>
<p><a href="https://sourceforge.net/projects/drm/files/dream/2.1.1/" target="_blank" rel="noopener"><center>Dream AM/DRM Receiver</center></a></p>
<p>Este programa está disponible para varios sistemas operativos, incluso podemos descargar el código fuente y compilarlo si queremos.<br>Para nuestro ejemplo, descargamos la versión 2.1.1 para Windows (<a href="https://sourceforge.net/projects/drm/files/dream/2.1.1/dream-2.1.1-win32-svn808-df.zip/download" target="_blank" rel="noopener">dream-2.1.1-win32-svn808-df.zip</a>). La versión 2.2 es muy similar pero presenta algunos errores de funcionamiento. Si aun así queremos probar esta versión, podemos descargarla desde <a href="https://www.reddit.com/r/RTLSDR/comments/grp6m2/dream_v221_for_windows_with_xheaac_support/" target="_blank" rel="noopener">aquí</a>.</p>
<p>Una vez tenemos el archivo descargado, debemos extraer su contenido en la ubicación que queramos.<br>Después necesitamos incluirle las librerías necesarias para que pueda decodificar el audio en formato AAC. Para ello descargamos los dos siguientes archivos y los guardamos en el directorio de Dream:</p>
<ul>
<li><a href="faad2_drm.dll">faad2_drm.dll</a></li>
<li><a href="libfaac.dll">libfaac.dll</a></li>
</ul>
<h2 id="Configuracion"><a href="#Configuracion" class="headerlink" title="Configuración"></a>Configuración</h2><p>El siguiente paso es configurar el programa para que reciba el audio desde SDR#. Para ello hacemos clic en <em>Settings</em>, <em>Sound Card</em>, <em>Signal Input</em> y en <em>Device</em> seleccionamos el <strong>cable de audio virtual</strong>.</p>
<img src="/2020/10/25/recibir-drm/input.png" class="" width="800" title="Entrada audio">


<h2 id="Recepcion"><a href="#Recepcion" class="headerlink" title="Recepción"></a>Recepción</h2><p>Una vez tenemos el programa escuchando por el cable de audio virtual, procedemos a sintonizar una emisión de DRM con SDR#. Usaremos el <strong>modo USB</strong> y un <strong>ancho de banda de 10 KHz</strong>.<br>Cuando Dream detecte la señal, veremos datos de la emisión en la ventana y comenzará a escucharse si tenemos señal suficiente. Los tres indicadores señalados en la siguiente imagen deben estar activos para poder escuchar el audio.</p>
<img src="/2020/10/25/recibir-drm/dream.png" class="" width="700" title="Dream">


<img src="/2020/10/25/recibir-drm/sdrSharp.png" class="" width="900" title="SDR# + Dream">
]]></content>
      <tags>
        <tag>SDRSharp</tag>
        <tag>Windows</tag>
        <tag>DRM</tag>
      </tags>
  </entry>
  <entry>
    <title>Recepción de mensajes ADS-B en Raspberry Pi</title>
    <url>/2020/05/03/seguimiento-aviones-raspberry-pi/</url>
    <content><![CDATA[<p>ADS-B (<em>Automatic Dependent Surveillance Broadcast</em>) es una tecnología de control en la que un avión determina su posición a través de la navegación por satélite y la emite periódicamente, lo que permite realizar su seguimiento.</p>
<p>En este artículo veremos como convertir una Raspberry Pi en un receptor de mensajes ADS-B y poder determinar y visualizar la posición de las aeronaves que sobrevuelan nuestra ubicación.</p>
<a id="more"></a>

<p>Lo primero que haremos será instalar nuestro dispositivo SDR, si todavía no lo hemos hecho, siguiendo los pasos descritos en <a href="https://sdr-es.com/2020/04/10/instalacion-rtlsdr-raspberrypi/">“Instalación de dispositivos RTL-SDR en Raspberry Pi”</a>.</p>
<h3 id="Instalacion-de-dump1090"><a href="#Instalacion-de-dump1090" class="headerlink" title="Instalación de dump1090"></a>Instalación de dump1090</h3><p>Vamos a instalar la versión de <em>dump1090</em> mantenida por FlightAware, ya que está actualizada y nos instala y levanta un servidor web en el que podemos ver las aeronaves sobre el mapa sin muchas complicaciones.</p>
<p>El primer paso es instalar el repositorio de FlightAware en nuestra Raspberry Pi dependiendo de la versión de Raspbian que tengamos. También podemos generar paquetes para otras distribuciones siguiendo los pasos descritos <a href="https://github.com/flightaware/dump1090" target="_blank" rel="noopener">aquí</a>.</p>
<p>Si no conocemos la versión de Raspbian, podemos consultarla ejecutando:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;os-release | grep VERSION_CODENAME</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Repositorio para <strong>Raspbian Buster</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;flightaware.com&#x2F;adsb&#x2F;piaware&#x2F;files&#x2F;packages&#x2F;pool&#x2F;piaware&#x2F;p&#x2F;piaware-support&#x2F;piaware-repository_3.8.1_all.deb</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i piaware-repository_3.8.1_all.deb</span><br></pre></td></tr></table></figure>
</li>
<li><p>Repositorio para <strong>Raspbian Stretch</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;flightaware.com&#x2F;adsb&#x2F;piaware&#x2F;files&#x2F;packages&#x2F;pool&#x2F;piaware&#x2F;p&#x2F;piaware-support&#x2F;piaware-repository_3.8.1~bpo9+1_all.deb</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i piaware-repository_3.8.1~bpo9+1_all.deb</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Una vez instalado el repositorio correspondiente ejecutamos:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>

<p>Ahora instalamos <em>dump1090</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y dump1090-fa</span><br></pre></td></tr></table></figure>

<p>Podemos ajustar las opciones de <em>dump1090</em> en su archivo de configuración:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;default&#x2F;dump1090-fa</span><br></pre></td></tr></table></figure>

<p>Editamos la siguiente línea con la ganancia y valor de PPM. Es aconsejable establecer un valor para la ganancia, ya que por defecto el nivel viene establecido en automático (-10) y no siempre proporciona buenos resultados.<br>Si tenemos más de un dispositivo SDR conectado introducimos su número de serie en <em>device-index</em>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RECEIVER_OPTIONS&#x3D;&quot;--device-index 0 --gain -10 --ppm 0&quot;</span><br></pre></td></tr></table></figure>

<p>Reiniciamos el servicio para que se apliquen los cambios.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service dump1090-fa restart</span><br></pre></td></tr></table></figure>

<p>Por último, accedemos a nuestra Raspberry Pi desde cualquier navegador web:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;IP_RASPBERRY:8080&#x2F;</span><br></pre></td></tr></table></figure>

<img src="/2020/05/03/seguimiento-aviones-raspberry-pi/dump1090.jpg" class="" width="900" title="dump1090 FlightAware">

<p>Esta interfaz web utiliza el puerto 8080 por defecto. Si queremos cambiarlo editamos el archivo de configuración de <em>Lighttpd</em>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;lighttpd&#x2F;conf-enabled&#x2F;89-dump1090-fa.conf</span><br></pre></td></tr></table></figure>

<p>Editamos la siguiente línea y modificamos el puerto 8080 por el que queramos utilizar:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$SERVER[&quot;socket&quot;] &#x3D;&#x3D; &quot;:8080&quot; &#123;</span><br></pre></td></tr></table></figure>

<p>Por último reiniciamos el servicio para que se apliquen los cambios:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service lighttpd restart</span><br></pre></td></tr></table></figure>


<h3 id="Enviar-datos-a-FlightAware"><a href="#Enviar-datos-a-FlightAware" class="headerlink" title="Enviar datos a FlightAware"></a>Enviar datos a FlightAware</h3><p><a href="https://flightaware.com/" target="_blank" rel="noopener">FlightAware</a> es una compañía con sede en Houston (TX, Estados Unidos) que ofrece servicios de software y datos para aviación. Esta compañía ofrece información de seguimiento de aeronaves de forma gratuita desde su página web y sus aplicaciones para móviles. Es actualmente la mayor plataforma de seguimiento de vuelos.</p>
<p>Podemos reenviar los datos de seguimiento a FlightAware desde nuestra Raspberry Pi. Estos serán utilizados para el seguimiento a nivel global y a cambio recibiremos una suscripción <em><a href="https://flightaware.com/commercial/premium/" target="_blank" rel="noopener">Enterprise</a></em>.</p>
<p>Los pasos para enviar los datos son los siguientes:</p>
<ol>
<li>Lo primero será registrarnos en FlightAware:</li>
</ol>
<p><a href="https://es.flightaware.com/account/join" target="_blank" rel="noopener"><center>https://es.flightaware.com/account/join</center></a></p>
<ol start="2">
<li><p>Instalamos <em>piaware</em>. Este software será el encargado de establecer la comunicación con el servidor de FlightAware para enviar los datos y recibir ajustes.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y piaware</span><br></pre></td></tr></table></figure>
</li>
<li><p>Podemos ajustar <em>piaware</em> para que se actualice de forma automática y para que podamos actualizarlo desde la interfaz web de FlightAware.<br>Si queremos que se actualice automático ejecutamos:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo piaware-config allow-auto-updates yes</span><br></pre></td></tr></table></figure>
<p>Si queremos que se pueda hacer de forma manual vía web ejecutamos:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo piaware-config allow-manual-updates yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>Reiniciamos el servicio para que se apliquen los ajustes.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service piaware restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>Accedemos a la siguiente dirección para vincular nuestra Raspberry Pi con la cuenta que acabamos de crear. Si accedemos desde la misma dirección IP que tiene la Raspberry Pi, la detectará de forma automática.</p>
</li>
</ol>
<p><a href="https://flightaware.com/adsb/piaware/claim" target="_blank" rel="noopener"><center>https://flightaware.com/adsb/piaware/claim</center></a></p>
<ol start="6">
<li>Vamos a nuestro panel de control y abrimos las opciones de configuración.</li>
</ol>
<img src="/2020/05/03/seguimiento-aviones-raspberry-pi/flightaware-panel.png" class="" width="900" title="FlightAware">

<ol start="7">
<li>Por último, introducimos nuestros datos de latitud, longitud y altitud para poder usar el seguimiento con MLAT y reiniciamos el servicio desde la propia web pulsando el botón <em>Send</em>.</li>
</ol>
<img src="/2020/05/03/seguimiento-aviones-raspberry-pi/flightaware-config.jpg" class="" title="FlightAware">


<h3 id="Enviar-datos-a-AirNav-RadarBox"><a href="#Enviar-datos-a-AirNav-RadarBox" class="headerlink" title="Enviar datos a AirNav RadarBox"></a>Enviar datos a AirNav RadarBox</h3><p><a href="https://www.radarbox.com/" target="_blank" rel="noopener">RadarBox</a> es una compañía con sede en Tampa (FL, Estados Unidos) que ofrece servicios de información de vuelos. Podemos compartir los datos que recibimos en nuestra Raspberry Pi con RadarBox y a cambio obtendremos una suscripción <em><a href="https://www.radarbox.com/subscribe" target="_blank" rel="noopener">Business</a></em>.</p>
<p>Las pasos que seguiremos son los siguientes:</p>
<ol>
<li><p>Instalamos <em>rbfeeder</em>. Será el programa que envíe los datos al servidor.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo bash -c &quot;$(wget -O - http:&#x2F;&#x2F;apt.rb24.com&#x2F;inst_rbfeeder.sh)&quot;</span><br></pre></td></tr></table></figure>
<p>Cuando pregunte si queremos instalar <code>dump978-rb</code> le decimos que no.</p>
</li>
<li><p>Instalamos el cliente de MLAT. La siguiente versión es para Raspbian. Si necesitamos paquete para otra versión, podemos generarlo siguiendo los pasos descritos <a href="https://github.com/mutability/mlat-client" target="_blank" rel="noopener">aquí</a>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;sdr-es.com&#x2F;2020&#x2F;05&#x2F;03&#x2F;seguimiento-aviones-raspberry-pi&#x2F;mlat-client_0.2.11_armhf.deb</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo dpkg -i mlat-client_0.2.11_armhf.deb</span><br></pre></td></tr></table></figure>
</li>
<li><p>Nos registramos en RadarBox.</p>
</li>
</ol>
<p><a href="https://www.radarbox.com/register" target="_blank" rel="noopener"><center>https://www.radarbox.com/register</center></a></p>
<ol start="4">
<li><p>Una vez registrados necesitamos vincular nuestro receptor con RadarBox. Para ello usaremos la clave que nos genera <em>rbfeeder</em> la primera vez que se conecta al servidor. Consultamos la clave con el comando:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rbfeeder --showkey --no-start</span><br></pre></td></tr></table></figure>
</li>
<li><p>Accedemos a esta dirección, introducimos nuestra clave en <em>Sharing Key</em> y pulsamos en <strong>CLAIM!</strong>.</p>
</li>
</ol>
<p><a href="https://www.radarbox.com/raspberry-pi/claim" target="_blank" rel="noopener"><center>https://www.radarbox.com/raspberry-pi/claim</center></a></p>
<img src="/2020/05/03/seguimiento-aviones-raspberry-pi/radarbox-claim.jpg" class="" width="900" title="RadarBox">


<ol start="6">
<li>Por último introducimos nuestras coordenadas cuando nos lo pida.</li>
</ol>
<h3 id="Enviar-datos-a-ADS-B-Exchange"><a href="#Enviar-datos-a-ADS-B-Exchange" class="headerlink" title="Enviar datos a ADS-B Exchange"></a>Enviar datos a ADS-B Exchange</h3><p><a href="https://www.adsbexchange.com/" target="_blank" rel="noopener">ADS-B Exchange</a> es un servicio colaborativo de datos de seguimiento y es la mayor fuente de datos de vuelos <strong>sin filtrar</strong>. En este caso no obtendremos beneficios como suscripciones, ya que este servicio ofrece todos los datos de forma <strong>gratuita para fines no comerciales</strong>.</p>
<p>Para enviar nuestros datos a ADS-B Exchange tendremos que ejecutar un script de instalación que realizará el proceso de forma sencilla. Para ello ejecutamos el siguiente comando:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo bash -c &quot;$(wget -nv -O - https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;adsbxchange&#x2F;adsb-exchange&#x2F;master&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure>

<p>Se iniciará un asistente instalación en el que debemos indicar un nombre para nuestro <em>feeder</em> y nuestra posición para los cálculos de MLAT.</p>
<img src="/2020/05/03/seguimiento-aviones-raspberry-pi/adsb-script.png" class="" title="Asistente instalación ADS-B Exchange">

<p>Una vez finalice el asistente, ya estaremos conectados y enviando datos a ADS-B Exchange. Para conocer el estado del servicio tenemos los siguientes enlaces:</p>
<ul>
<li>Comprobar el estado de nuestro <em>feeder</em>: <a href="https://adsbexchange.com/myip/" target="_blank" rel="noopener">https://adsbexchange.com/myip/</a></li>
<li>Comprobar el estado de los servidores de MLAT: <a href="http://adsbx.org/sync" target="_blank" rel="noopener">http://adsbx.org/sync</a></li>
</ul>
<p>Opcionalmente, podemos instalar la herramienta proporcionada por ADS-B Exchange para ver online los datos que estamos enviando desde nuestro receptor en tiempo real. Para instalarla basta con ejecutar el siguiente comando:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo bash -c &quot;$(wget -nv -O - https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;adsbxchange&#x2F;adsbexchange-stats&#x2F;master&#x2F;stats.sh)&quot;</span><br></pre></td></tr></table></figure>

<p>Una vez instalada, ejecutamos el siguiente comando para obtener nuestra URL personalizada en la que consultar los datos:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adsbexchange-showurl</span><br></pre></td></tr></table></figure>

<p>Obtendremos una URL que debemos copiar e introducir en el navegador web. Una vez accedemos, tendremos dos enlaces que nos llevarán a una página con los datos de las aeronaves que estamos recibiendo en nuestra estación y a un visor con el mapa en tiempo real. Podemos consultar el funcionamiento de las distintas opciones del visor en <a href="https://www.adsbexchange.com/map-help/" target="_blank" rel="noopener">este enlace</a>.</p>
<img src="/2020/05/03/seguimiento-aviones-raspberry-pi/adsb-exchange.jpg" class="" width="900" title="ADS-B Exchange">


<h3 id="Enviar-datos-a-Flightradar24"><a href="#Enviar-datos-a-Flightradar24" class="headerlink" title="Enviar datos a Flightradar24"></a>Enviar datos a Flightradar24</h3><p><a href="https://www.flightradar24.com/" target="_blank" rel="noopener">Flightradar24</a> es una compañía europea con sede en Estocolmo (Suecia) que ofrece servicios de información de vuelos. Compartiendo nuestros datos con Flightradar24 obtendremos una suscripción <em><a href="https://www.flightradar24.com/premium" target="_blank" rel="noopener">Business</a></em>.</p>
<p>Lo primero sera registrarse en Flightradar24.</p>
<p><a href="https://www.flightradar24.com/premium/signup" target="_blank" rel="noopener"><center>https://www.flightradar24.com/premium/signup</center></a></p>
<p>Para enviar los datos debemos descargar e instalar <em>fr24feed</em>. Para ello ejecutamos el siguiente comando y seguimos los pasos del asistente de instalación.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo bash -c &quot;$(wget -O - https:&#x2F;&#x2F;repo-feed.flightradar24.com&#x2F;install_fr24_rpi.sh)&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Introducir el correo electrónico con el que nos hemos registrado.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Step 1.1 - Enter your email address (username@domain.tld)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Si tenemos ya una clave previa la introducimos. En caso contrario lo dejamos en blanco.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Step 1.2 - If you used to feed FR24 with ADS-B data before, enter your sharing key.</span><br><span class="line">If you don&#39;t remember your sharing key, you can find it in your account on the website under &quot;My data sharing&quot;.</span><br><span class="line">https:&#x2F;&#x2F;www.flightradar24.com&#x2F;account&#x2F;data-sharing</span><br><span class="line"></span><br><span class="line">Otherwise leave this field empty and continue.</span><br></pre></td></tr></table></figure>
</li>
<li><p>Introducimos <code>yes</code> para activar MLAT.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Step 1.3 - Would you like to participate in MLAT calculations? (yes&#x2F;no)$:yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>Introducimos nuestras coordenadas y altitud.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IMPORTANT: For MLAT calculations the antenna&#39;s location should be entered very precise!</span><br><span class="line"></span><br><span class="line">Step 3.A - Enter antenna&#39;s latitude (DD.DDDD)</span><br><span class="line"></span><br><span class="line">Step 3.B - Enter antenna&#39;s longitude (DDD.DDDD)</span><br><span class="line"></span><br><span class="line">Step 3.C - Enter antenna&#39;s altitude above the sea level (in feet)</span><br><span class="line"></span><br><span class="line">Using latitude: 37.XXXX, longitude: -3.XXXX, altitude: 720ft above sea level</span><br><span class="line"></span><br><span class="line">Validating email&#x2F;location information...OK</span><br><span class="line"></span><br><span class="line">The closest airport found is ICAO:LEGR IATA:GRX near Granada.</span><br><span class="line"></span><br><span class="line">Latitude: 37.188728</span><br><span class="line">Longitude: -3.777350</span><br><span class="line">Country: Spain</span><br><span class="line"></span><br><span class="line">Flightradar24 may, if needed, use your email address to contact you regarding your data feed.</span><br><span class="line"></span><br><span class="line">Would you like to continue using these settings?</span><br><span class="line"></span><br><span class="line">Enter your choice (yes&#x2F;no)$:yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>Introducimos <code>yes</code> para que usar la configuración automática y que utilice la instancia de <em>dump1090</em> que ya tenemos instalada.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">We have detected that you already have a dump1090 instance running. We can therefore automatically configure the FR24 feeder to use existing receiver configuration, or you can manually configure all the parameters.</span><br><span class="line"></span><br><span class="line">Would you like to use autoconfig (*yes*&#x2F;no)$:yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>Activamos el log si queremos. No es necesario.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Step 6 - Please select desired logfile mode:</span><br><span class="line"> 0 -  Disabled</span><br><span class="line"> 1 -  48 hour, 24h rotation</span><br><span class="line"> 2 -  72 hour, 24h rotation</span><br><span class="line">Select logfile mode (0-2)$:0</span><br></pre></td></tr></table></figure>
</li>
<li><p>Por último, reiniciamos el servicio.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart fr24feed</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>RTL-SDR</tag>
        <tag>Raspberry Pi</tag>
        <tag>ADS-B</tag>
        <tag>dump1090</tag>
      </tags>
  </entry>
  <entry>
    <title>Seguimiento de satélites con Orbitron</title>
    <url>/2020/01/23/seguimiento-satelites-orbitron/</url>
    <content><![CDATA[<p>Una de las posibilidades más interesantes que nos ofrecen los dispositivos SDR es el poder recibir señales desde algunos satélites que orbitan el planeta en lo que se denomina órbita baja (LEO o Low Earth Orbit). Si queremos recibir su señal tendremos que estar atentos al momento en el que pasan por encima de nuestra posición. Para ello se usan programas que nos indican en qué posición se encuentra un satélite en un determinado instante de tiempo utilizando los datos de su órbita.<br>Existen distintos programas para Windows que realizan esta predicción. Uno de ellos es Orbitron, y es el que veremos en este tutorial.</p>
<a id="more"></a>

<h2 id="Instalacion-de-Orbitron"><a href="#Instalacion-de-Orbitron" class="headerlink" title="Instalación de Orbitron"></a>Instalación de Orbitron</h2><p>El primer paso es descargar Orbitron desde su web: <a href="http://www.stoff.pl/downloads.php" target="_blank" rel="noopener">http://www.stoff.pl/downloads.php</a></p>
<p>Tenemos la opción de descargarnos el instalador o un archivo ZIP. En este ejemplo vamos a descargar el ZIP y lo vamos a extraer en el directorio <em>C:\SDR\Orbitron</em>.</p>
<p>Ejecutamos ahora el programa haciendo doble click en <strong>Orbitron.exe</strong> y se nos abrirá la interfaz del programa. Nos pedirá que actualicemos los archivo de TLE al iniciar, a lo que le decimos que no. Más adelante veremos qué son estos archivos y cómo actualizarlos.</p>
<img src="/2020/01/23/seguimiento-satelites-orbitron/orbitron.jpg" class="" title="Orbitron">

<h2 id="Configuracion-de-Orbitron"><a href="#Configuracion-de-Orbitron" class="headerlink" title="Configuración de Orbitron"></a>Configuración de Orbitron</h2><p>Vamos ahora a configurar Orbitron con los ajustes básicos.</p>
<p>El primer ajuste es indicarle nuestra localización. Para ello vamos a la pestaña Location e introducimos nuestros datos. Si no los sabemos podemos buscar nuestra ciudad (o las más cercana) en el listado que tenemos a la derecha. Lo ideal es meter los valores más exactos posibles.</p>
<img src="/2020/01/23/seguimiento-satelites-orbitron/orbitron-location.jpg" class="" title="Orbitron Location">

<p>Una vez los tengamos introducidos correctamente, hacemos click en <strong>Choose</strong> para seleccionar esta ubicación.</p>
<p>El siguiente paso es seleccionar el archivo con los TLE de los satélites que vamos a seguir.<br>Estos archivos TLE contienen un listado de objetos que orbitan la Tierra con sus respectivos elementos orbitales en formato TLE <em>(two-line element set)</em>. Con estos elementos, y usando la fórmula adecuada, podemos estimar la posición y velocidad del objeto en cualquier instante de tiempo pasado o futuro.</p>
<p>Aquí tenemos varias opciones, utilizar los archivos TLE descargados por Orbitron, o bien crear un archivo con los satélites que nos interesen. Si optamos por la primera opción, necesitamos primeramente actualizar los archivos TLE. Para ello abrimos la ventana de ajustes de Orbitron presionando las teclas <strong><em>Alt+F5</em></strong>, o bien hacemos click en el siguiente punto y seleccionamos <strong>Setup</strong>:</p>
<img src="/2020/01/23/seguimiento-satelites-orbitron/orbitron-setup.jpg" class="" title="Orbitron Setup">

<p>Vamos a la pestaña <strong>TLE updater</strong> y hacemos click en el siguiente icono:</p>
<img src="/2020/01/23/seguimiento-satelites-orbitron/setup-tle.jpg" class="" title="Actualizar TLE">

<p>Una vez se actualicen los archivos, cerramos esa ventana y hacemos click en <strong>Load TLE</strong> y seleccionamos el archivo que contenga los satélites que queremos seguir. En este caso vamos a elegir un archivo que contiene los TLE de algunos satélites que nos interesan.</p>
<img src="/2020/01/23/seguimiento-satelites-orbitron/load-tle.jpg" class="" title="Cargar archivo">

<p>Ahora bastaría con ir seleccionando los satélites que queremos seguir y se mostrarán sobre el mapa.</p>
<img src="/2020/01/23/seguimiento-satelites-orbitron/orbitron-loaded.jpg" class="" title="Orbitron">

<p>En siguientes tutoriales veremos cómo conectar Orbitron con SDR# para realizar seguimientos automáticos.</p>
]]></content>
      <tags>
        <tag>Orbitron</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
</search>
